{"./":{"url":"./","title":"简介","keywords":"","body":"简介 本文档为皓月的Android使用及设计文档。主要包含了皓月框架的详细使用方式，以及框架的设计理念。 运行 安装 GitBooknpm install gitbook-cli -g Clone 代码到本地并运行git clone git@gitlab.mljr.com:moon-android/moon_doc.git cd moon_doc gitbook install gitbook serve 在浏览器中打开 http://localhost:4000/ 进行访问 发布 --测试环境 sh test.sh 在浏览器中打开 http://192.168.49.104/moon-android/ 进行访问 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-08-12 15:26:26 "},"kit/":{"url":"kit/","title":"组件间的桥梁-Kit","keywords":"","body":"Kit库 1. kit库的由来 在app开发时，绝大数情况下，都需要一些基础能力，例如网络请求，数据存储等。一般的功能依赖如下图所示： 这些基础能力都是app开发的通用能力，我们希望皓月能提供所有必要的基础功能，如图： 但是如此架构会有一些问题，例如app已经集成了缓存功能，不需要皓月中的缓存组件。再例如只是开发一个小的功能模块，只需要网络功能，不需要其他能力。所以，我们希望皓月库能满足依赖最小化的需求，通过依赖配置，自主定义功能组件是否集成。 同时，不同组件之间，可能有一些功能上的依赖。例如我们的缓存库会依赖数据库，网络库会依赖缓存库。我们希望各个组件库之间是透明的，他们不互相耦合。依赖的组件功能是否可用只是通过相关配置是否存在而决定。依赖的组件功能是由谁提供，也是由配置决定。所以我们最终结构如下： 如图所示，中间的皓月层，在我们的皓月库中被映射为kit组件，他提供了各个组件的功能定义、组件注册、常用开发工具集。我们约定，子库开发都需要依赖kit库，可以正常使用kit中定义的开发工具集和各种组件功能，但是需要注意是否该功能已被注册，否则将功能无效。我们约定，你可以通过组件的定义规范去桥接自有功能，注册自有组件到皓月框架中。 2. 组件接入 要接入一个组件，需要考虑如下几个问题： 在kit中，什么是一个组件？ 如何抽象组件定义？ 在哪暴露功能，让外部知道我有此功能 组件在哪进行注册？ 根据以上四个问题，我们一一进行讨论。 2.1. kit中组件的定义 在kit库的由来一节中讲到，我们的每个独立功能都可以看做是一个组件，引用上图： 如上图，第一排的每个功能方块，都是一个组件，都可以在kit中进行抽象定义，再在自己的子库中依赖kit，实现kit中的接口声明。在子库中进行实现时，我们需要提供一个子库入口，方便kit进行自动初始化组件和方便kit提供组件运行环境。在kit中，我们定义IComponent接口作为组件标准入口。他的声明如下： interface IComponent { fun init(app: Application) { Logcat.register(this) init(DefaultEnvironment(app)) } fun init(env: Environment) } 主要定义了两个init方法，用作组件的初始化入口方法。一般情况下只需要关注fun init(env: Environment)方法即可，它以运行环境为入参，供组件使用，以及供kit初始化使用。Environment的定义如下： interface Environment { /**app的默认缓存路径*/ fun appCacheDir(): File /**app的默认文件路径*/ fun appDir(): File /**是否是开发模式*/ fun isDebug(): Boolean /**Application包装类*/ fun application(): IApplication? /**当前Context的实例*/ fun app(): Context } 我们看到，他提供了我们常用的application、context、当前是否为debug和一些文件路径。 实现IComponent接口，你就进行了一个组件声明。 2.2. 抽象组件定义 皓月组件可以分为两种：需要在kit中声明的十分通用的组件，和基于kit开发，但是不是特别通用的单独组件，例如ocr系列组件。是否需要在kit中进行声明，取决于组件提供的功能是否足够通用。下面我们讨论的组件抽象都是基于在kit中进行声明的组件。 在kit库的由来中我们了解到，我们之所以要做库的能力抽象是为了提供两种能力：通用组件间尽量相互解耦，不互相依赖，和通用组件随时可更换，方便进行功能注册。所以基于以上两点，我们抽象的原则也就很清晰。我们的抽象只要能清楚表达出你的库能力即可，只要能让使用者只关心你的接口api，而不用关心你的实现即可。一般情况下我们在kit组件中，会分出一个个的包给代表每个能力的组件，如图： 你也可以在kit中新建你自己的包来存放你的能力定义。 2.3. 进行功能声明 当一个库提供了多种常用功能，给用户一个统一的功能入口，让用户能快速找到想要的功能，是一个可行的办法。在kit库中，我们提供了CommonSdk单例类来做这个事情。CommonSdk中提供了所有的kit库常用组件功能声明，如图： 当做完自己的实现后，可在此进行声明。我们对于部分简单功能，会在kit中直接实现，例如json解析的封装。对于没有在kit中进行实现，只是在kit中进行了声明的组件，是否有实现库，依赖于是否添加了相关引用依赖。所以对于每个只有声明的api一般会对应一个判断方法，用于给使用方判断，当前kit声明的api是否可用，如图： 至此，你基本就完成了一个组件在kit中的实现、抽象、声明几个步骤，最后我们看一下，一般情况下，如何进行组件注册。 2.4. 注册组件 一个组件的存在分两种形式，一种是他属于皓月组件群的一员而存在，一种是他独立存在。当他属于皓月组件群的一员时，用户第一时间感知到皓月框架，我们通过用户初始化kit库而初始化每个子组件。当他是独立存在时，用户第一时间感知到的是组件本身，我们通过用户初始化组件，关联初始化kit库。 我们知道，组件的入口必须实现IComponent接口，而一个组件一般应该只有一个入口，所以我们约定，实现IComponent接口的类必须为单例类，必须提供对外的静态实例：INSTANCE。在kotlin实现中，只要实现类为object类型即可，因为他的字节码实现会自动生成一个INSTANCE静态成员变量。在java实现中，需要我们自己提供一个静态成员变量INSTANCE。静态成员变量INSTANCE将作为Kit自动初始化子组件的入口。 我们考虑一下为什么可以是单例？因为我们的IComponent的实现类只是作为组件入口而存在，基本没必要存在多个入口实例，所以我们约定默认为单例实现。在IComponent定义中，提供了初始化方法，一般情况下在此方法中进行组件必要的初始化操作和在kit中进行注册操作。kit提供了ComponentsInstaller的单例类作为组件的注册入口，你可以在此类中实现自己的注册方法，并在CommonSdk中开放组件功能。我们下面以缓存组件为例，看一下注册流程： 第一步：抽象缓存组件定义，并新建cache包，将抽象的接口在cache包中声明。 第二步：新建缓存组件项目，并引用kit库，实现kit库中的标准接口，并实现相关功能逻辑 第三步：在kit库的ComponentsInstaller中定义注册入口 /** * 初始化硬盘缓存对象，需要调用方自己实现基于[com.meili.moon.sdk.cache]包定义的标准 * * 在使用api之前，必须先调用本方法做初始化 */ @JvmStatic fun installCache(cache: MoonCache, env: Environment? = null) { // 缓存对象 mCache.setOnceNoError(cache) // 尝试初始化kit的上下文 if (env != null) { installEnvInternal(env) } } 第四步：在kit库的CommonSdk中提供cache相关api，方便用户查找和使用 /**获取通用文件缓存对象，如果不能确认是否有缓存库，请先调用[isCache]方法进行判断*/ @JvmStatic fun fileCache(cacheDir: File? = null) /**获取通用缓存对象，如果不能确认是否有缓存库，请先调用[isCache]方法进行判断*/ @JvmStatic fun cache() 至此，就完成了cache库的注册和实现。 2.5. 子组件的自动初始化 在向kit的ComponentsInstaller中注册组件时，我们的示例要求使用environment初始化kit，这里有两个作用： kit中提供的很多方便的工具api都依赖Application对象，例如通过Application获取某个系统Service之类。所以，要使用kit的工具集，本身就需要提供上下文环境。 在设置kit的环境参数时，我们会尝试触发子组件的自动初始化。子组件的收集是通过moon-kit插件进行的，收集完成后就可以在运行时自动初始化每个子组件。 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-08-13 11:31:55 "},"kit/Utils.html":{"url":"kit/Utils.html","title":"开发工具集","keywords":"","body":"Kit常用工具集 kit作为皓月其他库的依赖库，提供子库的功能抽象声明，同时还有为子库提供开发常用工具集。 kit库的工具集全部定义在util包下。大体分为：加密工具、String工具、collection工具、反射工具、in/output工具、设备信息工具、App工具等，如图： 在开发过程中，有时会遇到一些不好分类的工具方法，但是又比较常用，可临时放到util/Utils.kt或者util/KotlinExtend.kt文件中，这两个文件暂时没有差别，都是用作存放不好归类的api。待到相关类型的api越来越多后，按照相关维度再做文件拆分。 工具方法是否可以放到kit库中，唯一的衡量标准是：是否通用。这个需要我们自己衡量和维护。 1. 加密工具 加密常用工具类定义在util.encrypt包中。主要包含常用的三种加密编码，分别是：AESUtils、Base64、MD5。 你可以将你需要的更多加密方式在此包中进行扩展。 2. String工具 String常用工具类定义在StringUtil.kt中。分为字符串的转换、字符串内容判断、字符串和系统交互。常用api如下： /**转换数组为16进制文本*/ fun ByteArray.toHexString(): String /** * 字符串半角转换为全角 * * 半角空格为32,全角空格为12288. * 其他字符半角(33-126)与全角(65281-65374)的对应关系是：均相差65248 */ fun String.half2Full(): String /** * 是否是以给定的字符串开头，只要满足一个就返回true */ fun CharSequence.startWith(vararg prefix: CharSequence, ignoreCase: Boolean = false): Boolean /*** * 复制text到黏贴板 * @return true 复制成功， false 复制失败 */ fun CharSequence?.copy2Clipboard(): Boolean 3. 集合扩展工具 集合常用工具类定义在CollectionUtils_.kt中，他主要扩展了一些常用foreach，例如： /** * 从0遍历到当前值 * * [include]表示是否包含当前值，默认不包含，如果包含则遍历总数为：当前值+1 */ inline fun Int.foreach(include: Boolean = false, lambda: (item: Int) -> Unit) /** * 反向遍历一个区间值，也可以直接使用downTo方法 * */ inline fun IntRange.foreachInverse(lambda: (item: Int) -> Unit) /** * 遍历当前集合，入参[lambda]的第一个参数为当前循环的index，第二个参数为当前集合的item对象。 * 如不需index信息，请参考另外一个[forEach]方法 */ inline fun SparseArray.forEach(lambda: (index: Int, item: T) -> Unit) 你也可以将你常用的集合扩展方法放到这里。 4. 反射工具 皓月库中用到了一些反射相关技术，也整理了一些常用反射工具方法，位于ReflectExtras_.kt文件中。我们先大概了解一下kotlin中反射类的关系： 更详细的内容，可参照KotlinReflect解析 从上图可知，我们常用的class、function、param等都是从KAnnotatedElement继承而来。所以我们将一些通用方法放到KAnnotatedElement类型上进行扩展，例如： /** * 当前KAnnotatedElement是否是一个List */ val KAnnotatedElement?.isList: Boolean /** * 当前类型是否是java的基本类型，包括包装的对象类型和基本类型，例如Boolean和boolean * * 这里的基本类型不包含Void类型 */ val KAnnotatedElement?.isPrimitive: Boolean /** * 获取当前KParameter的类型class，例如：val a = 1。他的class应该为Int */ val KParameter?.clazz: KClass? /** * 获取包含一个泛型的lambda传参中的泛型KClass信息 * * 例如： * test { * } * fun test(lambda: (T)->Unit){ * val paramClass = lambda.reflect1Class() // paramClass == String::class * } */ fun Function?.reflect1Class(): KClass? /**从一个对象复制相同属性名称的内容到另一个对象，忽略错误*/ fun Any?.copyFrom(from: Any?) /** * 获取匿名内部类的外部引用。一般情况下用于获取lambda表达式的外部实例引用。 * 在kotlin中，如果lambda表达式，没有直接使用外部类的内容，则lambda中不会持有其引用。 * 例如： * class TestOutClassReference{ * fun testLambda(lambda: ()->Unit){ * * } * } * * class A{ * fun test(){ * val testOutClass = TestOutClassReference() * testOutClass.testLambda{ * } * } * } * class B{ * var value = 3 * fun test(){ * val testOutClass = TestOutClassReference() * testOutClass.testLambda{ * value = 4 * } * } * } * 在上面的例子中： * A中的调用，testLambda方法中，没有类A的外部引用，只有匿名内部类的实例引用：INSTANCE。使用此方法获取时，返回值为null。 * B中的调用，由于在lambda中重新赋值了B.value参数值，所以在testLambda中的入参lambda会持有外部类B的实例引用，可以通过此方法获取到类B对象。 */ fun Any?.getOutClassInstance(): T? 5. in/output工具 in/output工具位于util包下的IOUtil.kt，此类中定义了一些流相关api： /**读取inputStream为字符串*/ fun InputStream.readText(charset: String = \"UTF-8\"): String /** * 在给定的Stream中读取指定字节数 * * 在给定的inputStream中读取[size]个字节，也可以指定跳过[skip]个字节后开始读取 */ @Throws(IOException::class) fun InputStream.readBytes(size: Long, skip: Long = 0): ByteArray /**关闭对象，带有try-catch*/ fun Closeable?.closeIt() /**获取文件的大小，如果是文件夹则将子文件循环加到一块*/ fun File.lengthRecursively(fileFilter: ((File) -> Boolean)? = null): Long /**创建一个文件*/ @Throws(IOException::class) fun String.createFile(): File 在这里你还可以补充更多的数据流相关api 6. 设备信息工具 kit工具集中封装了常用的设备信息相关工具，位于DeviceUtil.java中，需要进一步进行整理和完善，去除不常用工具方法。 7. App工具 app工具区别于设备信息工具，我们期望在其中存放app相关工具方法，而不是设备相关api，例如： /** 当前代码调用是否处于主进程 */ fun isMainProcess(): Boolean /**当前代码调用是否处于主线程*/ fun isMainThread(): Boolean Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-08-13 11:34:15 "},"kit/task_msg.html":{"url":"kit/task_msg.html","title":"Task","keywords":"","body":"皓月中的Task 顾名思义，task是指一个任务。 一个任务，可能是需要耗时的下载大文件，也可能只是用户登录，或者记录一个字段。任务的定义可大可小，大到可以做一系列的业务逻辑，最后完成返回一个Int结果；小到可以只是在SharedPrefrence中记录一个值。一个任务被定义出来，他往往就是可通用的，或者是被声明的。用地地方多了，自然就是一个通用的任务，例如：用户退出登录的逻辑，可能会在多种情况下触发，如下 你可以将上图中的退出登录逻辑提取为一个公用方法，大家都调用此方法即可；这种方式简单易用，同时也有很不错的可维护性。如果我们将客户端上的组合结构再扩展一点，将功能独立的逻辑代码使之组件化；当各个功能组件化以后，就面临通用任务如何共享的问题；可能在不同的组件中，都有对退出登录的需求，这时如果只是在某个组件方法中定义，就不好做到功能通用；如果将此方法下沉到基础库，而随着业务不断扩展和代码不断增加，基础库会不断膨胀，最终不得不进行拆分。 皓月针对类似问题，以声明的Task做业务处理，并通过Message的方式解耦组件通用功能。下面我们讨论一下在皓月中如何定义和使用Task。 1. 快速引入 由于实现很轻量，所以抽象和实现都在kit库中，引入kit库就集成了此功能。具体kit库的引入方式请参见：kit引入文档 2. 开始使用 Task相关的使用，大体分两步：定义并注册Task和启动Task 2.1. 定义和注册Task 要定义一个Task需要继承MessageTask。从MessageTask中，可以获取到启动此Task时的用户入参，以便在处理逻辑时使用。例如我们定义一个用户退出登录的Task，如下： /** * 用户退出登录Task */ class LogoutTask(msg: BaseMessage) : MessageTask(msg) { /**task任务执行*/ override fun doBackground() { // 是否清除本地的通用信息 val isClearCommonInfo = arguments.getBoolean(\"isClearCommonInfo\") // 第一步：通知服务器退出登录 // 第二步：清除本地的登录信息 // 第三步：根据入参，判断是否清除通用信息 // 第四步：设置退出登录结果 setResult(true) } } 在上例中我们看到，MessageTask上有个泛型，他的含义是此Task的结果是Boolean类型。我们还看到arguments.getBoolean(\"isClearCommonInfo\")，其中arguments成员变量就是用户启动Task时的入参Bundle。 下面我们将定义的task，在MessageRegistry中进行注册： MessageRegistry.register(\"common/logout\", LogoutTask::class.java) 在上述代码中，注册方法第一个参数为当前Task的消息Id，此Id在App内不可重复。后面需要使用此id启动退出登录Task。 到此，我们定义了用户退出登录的Task，并将它在皓月的task管理中进行了注册。 2.2. 启动Task 要启动我们前面定义的LogoutTask，需要一个新的对象：BaseMessage。他负责收集当前的用户参数和设置结果回调，例如： // task的启动入参 val taskArgs = Bundle() taskArgs.putBoolean(\"isClearCommonInfo\", true) // 新建一个退出登录Id的的消息体 val logoutMsg = BaseMessage(\"common/logout\") // 设置入参 logoutMsg.arguments = taskArgs logoutMsg.setCallback(object : MessageCallback() { override fun onSuccess(result: Boolean) { } override fun onError(exception: BaseException) { } override fun onFinished(isSuccess: Boolean) { } }) // 发送消息，启动任务，并得到一个可取消对象，用来取消任务 val cancelable = logoutMsg.send() 至此我们就定义、注册、启动了一个Task。 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-08-08 16:05:17 "},"kit/dev_tools/":{"url":"kit/dev_tools/","title":"快速开发皓月工具","keywords":"","body":"皓月的Gradle工具集 皓月的gradle工具，用来快速管理皓月库 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-07-15 11:11:04 "},"kit/dev_tools/moon_tools/MoonTools.html":{"url":"kit/dev_tools/moon_tools/MoonTools.html","title":"Lib库开发工具-MoonTools","keywords":"","body":"MoonTools MoonTools是为了皓月库快速开发而出现的gradle插件。 MoonTools主要提供了如下功能 Module的demo和lib模式切换，app模式下进行库的功能开发和测试，lib模式下进行库的打包和依赖.自动初始化demo所需文件。 Project中的全局maven依赖和project依赖切换，支持快速全局切换项目是project依赖还是maven依赖 本地maven与公司maven快速切换 1. 快速集成 在Project根目录的build.gradle中添加插件的依赖配置，如下: buildscript { repositories { //添加公司的maven私服 maven { url MAVEN_URL_PUBLIC } } dependencies { //添加MoonTools的插件包 classpath 'com.meili.moon.gradle:moon-tools:1.0.0' } } 引入插件 在Module的build.gradle中，删除原来引入的apply plugin: 'com.android.library'，并将MoonTools插件引入： //删除谷歌的Lib插件 //apply plugin: 'com.android.library' //添加MoonTools插件 apply plugin: 'moon-tools' 2. Module模式切换 当我们在开发一个Library项目时，有必要有一个配套的Demo对Library提供的api、功能¯¯进行调试、调优和回归。而通常情况下我们的一个Library会作为一个git项目进行版本管理，这样做的好处是一个Project中可以管理多个不同git的Module进行开发，坏处是这种管理方式很难优雅有效的管理配套Demo。MoonTools提供了Module级别的demo和library的快速切换功能。可以通过一个配置将当前Module设置为library或者demo模式。 由于我们是根据配置自动引入Android插件，所以在gradle中不兼容同时配置Android插件 2.1. 开始使用 MoonTools提供了moonTools代码块作为配置入口。 在模式切换功能下，我们提供了配置，指定当前是否为demo模式，如下： moonTools { //是否使用demo模式，默认为false useDemo true //是否使用kotlin插件，默认为true useKotlin true } 在开发demo时，难免会需要依赖一些第三方库。而谷歌提供的官方引入方式会导致我们在打包lib时存在冗余依赖，从而可能导致不必要的麻烦，增大引入体积。 针对这种情况，我们添加了 demo 关键字进行引入声明。使用 demo 方式引入的依赖，只有在DemoApp中可用，而在打包maven时会被过滤掉。具体的使用方式如下： dependencies { // 只在demo中生效的库依赖 demo 'com.android.support.constraint:constraint-layout:1.1.3' } 在引入MoonTools插件时，为了保证编译通过，我们会在Module的src目录下创建如下内容： src/demo/java/你的package/demo/MainActivity.kt 用做启动页 src/demo/res/drawable 用于存放资源文件 src/demo/res/drawable-xxhdpi/ic_launcher.png 用于作为app启动图标 src/demo/res/layout/activity_main.xml 用于首页布局 src/demo/res/values/(colors、strings、styles) 用于存放资源文件 src/demo/AndroidManifest.xml 作为manifest文件，同时将添加部分初始化内容。设置了demo的包名为：lib的包名 + demo的形式。设置了Application节点和启动Activity，你可以自行修改相关内容。 demo生成App的名称为：你的包名最后子包单词首字母大写 + Demo，例如：com.meili.moon.sdk，生成的app名称为SdkDemo 至此，你就可以用配置Application项目的方式配置demo目录内容，从而得到一个可运行的demo项目。而在发布maven时，只需要关闭demo模式即可正常发布。 3. Project的全局Maven/Project依赖切换 在大量开发有依赖关系的组件群时，有时我们为了增快开发节奏，需要直接以project的方式进行依赖，从而免去跨库修改代码而需要的频繁发布。而在代码相对稳定或者发布时，又需要将project的依赖方式改为maven的方式。整个过程繁琐，呆板，且容易出错。 针对以上需求，MoonTools为我们提供了如下功能： Project级别的全局切换所有Module中指定依赖的maven/project Module级别的自定义依赖方式，优先级高于全局配置 依赖级别的maven/project自定义配置，优先级高于Module配置 Module级别的强制依赖方式，优先级高于依赖自定义配置 Project级别的强制全局依赖方式，优先级高于Module级别的强制依赖方式 我们提供的以上配置方式，从上到下，优先级依次提高。当有高优先级配置时，低优先级配置不生效。在此声明，他们的优先级如下： 全局 3.1. 依赖的声明方式 为了便于管理配置，我们提供了用于依赖方式切换的依赖声明关键字：projectMaven。他的声明方式为两段式，用来提供project和maven的依赖配置，例如： dependencies { projectMaven 'moon_sdk_base|com.meili.moon.sdk:base:1.11.0' } 如上举例，我们的声明格式为：projectMaven 'module名称 + 竖线(|) + maven依赖' 当配置决定使用module依赖时，则使用前半部分。在使用maven依赖时，则使用后半部分。 3.2. 配置依赖方式 前文提到，我们提供5种不同优先级的依赖定义方式，他们具体的配置方式如下： 全局配置 在Project中的gradle.properties中可以通过moon.isAllMaven进行设置，例如： #设置全局配置为使用maven moon.isAllMaven=true Module配置 在Module中的build.gradle中，可以在moonTools代码块进行设置，例如： moonTools { //当前项目依赖方式：0 maven依赖(默认)，1 project依赖。其他值都认为是maven依赖 allMaven 0 } 在此情况下，如果当前配置和全局配置有冲突，则以当前配置为准 依赖级别配置 全局配置和Module配置可以满足不同级别的整体配置，而在个别情况下，你可能希望只针对个别依赖设置依赖方式。我们提供在依赖前添加 ^ 符号进行特殊设置。带有 ^ 符号的将忽略全局配置和module配置，直接使用被标记的依赖方式作为依赖。例如： dependencies { projectMaven 'moon_sdk_base|^com.meili.moon.sdk:base:1.11.0' } 这种情况下，就算配置了module中的 allMaven 1 ，当前依赖也会使用maven的方式进行依赖。全局配置同理。 如果两段配置都有 ^ 标记，则project依赖上的标记会起作用。 Module中的强制方式 如果在配置过程中，配置较复杂，不想对Module中的内容逐一更改，可以使用此方式强制指定当前Module的依赖方式，如下： moonTools { //当前项目依赖方式：0 maven依赖(默认)，1 project依赖 allMaven 1 //当前项目依赖方式，如果设置此值，则上面的allMaven会无效，：0 maven依赖，1 project依赖，其他值 等同于没有设置此值 forceAllMaven 1 } 当前配置会忽视上3种配置，直接使用当前配置作为依据 Project中的强制方式 如果在配置过程中，配置较复杂，不想对所有Module的内容进行逐一修改，可使用此方式强制指定所有Module的依赖方式。 此功能需要在Project级别的gradle.properties文件中进行配置，如下： //强制项目中所有module的依赖方式，有三种设置方式：true 强制为maven，false 强制为project，不设置 不强制任何方式 moon.forceAllMaven=false 在例子中我们知道，如果不需要强制，则请删除此配置，或者注释掉配置，true和false都是有特殊含义的。 如果有此配置，则上述4种配置将被忽略，直接使用强制指定的配置方式 4. Maven的本地/服务器发布快速切换 功能暂未完成 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-08-13 11:32:57 "},"kit/dev_tools/moon_tools/python插件.html":{"url":"kit/dev_tools/moon_tools/python插件.html","title":"批量升级工具","keywords":"","body":"python升级脚本 由于我们在开发类库的时候，开发完成之后不仅要升级自己的类库，还要将依赖的这个类库的其他类库也要按照关联的先后顺序一一升级，对于这个难题皓月开发了批量升级工具是能够帮助你通过一行命令快速升级版本库和按依赖顺序升级关联的版本库并且上传到maven库中。 1.快速集成 将upload.python复制到你项目的根目录 文件 2.使用方式 只需要在terminal中输入命令即可。 命令：python upload.py 要升级的库的名字 例如：python upload.py moon_share 升级分享库和依赖分享库的其他库。 3.详解 使用插件的时候会生成两个文件项目名+CurrentVersionTemp.temp和HighlibVersionReview.properties 3.1.项目名+CurrentVersionTemp.temp 为升级过程中的临时文件，位于根目录的build下面，记录当前包的版本信息和升级过程中依赖库的成功与失败，如果最终整个链上的库都升级完毕后，会删除该文件，如果升级失败，可以在文件中查看到失败的库是哪个，例如： 代表着生机的库是moon_share,失败的库是moon_sdk_web_bridge 3.2.HighlibVersionReview.properties文件 在脚本运行的时候会抓取每个库的maven.gradle文件中的MAVEN_ARTIFACT_ID 的版本号最为最新的版本信息记录下来。库文件升级的时候会将build.gradle中依赖的库按照这个表替换为最新的库，然后再去升级。 4.错误机制 当你升级库的时候，如果上传失败，只需要修改错误后再次运行脚本即可，会自动帮你跳过已经打包成功的包，然后继续打包直到这个关联的链上库都升级完成，例如 ： 升级的链为 A -> B -> C 此时 升级失败了说明链中存在错误，一般失败分两种情况 如果C失败了，修改C 再次升级 则 A 和B 直接跳过，重新打包C 如果C失败了，修改 A ，因为A已经成功打包，但是修改了A，这时候调整了A的版本号，才会再次将A打包，再次升级 则会重新升级整条链上的库 5.整体流程 5.1准备操作： 先遍历整个文件夹 寻找所有可编译的库lib_list。 然后遍历整个文件夹，初始化所有model的Library的信息 根据输入的要升级的库，去做升级操作。 5.2确定升级序列 升级操作 是先发送升级报告给依赖库 收到消息的依赖库，维护一个队列，将收到的消息存储下来准备升级，然后依赖库将向自己要升级的消息继续发送给她的依赖库 直到发送到顶层的的依赖库，这样就确定好整个依赖的升级序列。 5.3升级 当确定好升级队列后，先升级第一个版本库 如果是升级依赖的版本库，需要1.先修改maven.gradle中MAVEN_VERSION的版本，默认升级最小的版本号加一，然后2.要将build.gradle中的依赖替换为最新的依赖， 5.4发送消息 升级完成之后，发送升级完成的报告给依赖库，收到消息的依赖库，将自己队列中存储的消息清除，然后判断消息队列中是否有其他消息，如果没有其余消息，就开始做自己的升级操作，升级完成之后，继续向他的依赖通知消息，如果有其他消息，就不做任何操作，直到没有消息，才开始升级 5.5整体流程图 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-09-11 10:29:10 "},"kit/dev_tools/moon_tools/UpgradeLog.html":{"url":"kit/dev_tools/moon_tools/UpgradeLog.html","title":"moon-tools更新日志","keywords":"","body":"moon-tools更新日志 v1.2.10 添加permission插件功能 v1.0.2 修复了引入moon-tools后，作为lib项目，带有res的项目，R文件找不到，不能打包的bug Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-10-30 14:26:07 "},"kit/kit_import.html":{"url":"kit/kit_import.html","title":"Kit库引入","keywords":"","body":"Kit库快速集成 快速集成 在Project根目录的build.gradle中添加全局的依赖配置，如下: allprojects { repositories { //添加公司的maven私服 maven { url MAVEN_URL_PUBLIC } } } 引入kit库 在Module的build.gradle中，添加kit库的Maven依赖：dependencies { implementation(\"com.meili.moon.sdk:kit:版本号\") } 如果使用的是moon-tools插件，添加kit库的Maven依赖方式为：dependencies { projectMaven(\"moon_sdk_kit|com.meili.moon.sdk:kit:版本号\") } kit库的版本号，请参见：kit更新文档 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-08-13 11:34:35 "},"kit/UpgradeLog.html":{"url":"kit/UpgradeLog.html","title":"更新日志","keywords":"","body":"Kit库更新日志 v1.6.1 新增log中的traceCount设置，支持自定义trace打印数量 新增permission的config选项：isDirectDeniedRememberUE，支持直接使用setting弹出框，忽略反复授权提醒 v1.6.0 优化log中的api，减少不常用api展示 优化permission接口功能 v1.4.0 优化Log打印，支持更友好的默认log日志 优化自动组件注入 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-11-06 18:16:42 "},"log/":{"url":"log/","title":"日志管理","keywords":"","body":"日志管理 在我们平时的子库开发中，在调试阶段需要在关键节点进行日志打印，方便跟踪数据变化，调试代码。所以往往子库可能会封装自己的日志工具，导致代码重复，且易重名，在上层应用中可以找到很多重名日志工具，浪费人力且容易造成困扰。皓月日志管理工具提供了如下功能： 支持多子库的日志打印，子库可动态注册/解注打印器。 支持默认日志打印器，方便快速接入 支持Kotlin的扩展方式进行日志打印，方便随时随处插入日志 我们默认的日志输出格式如下： 日志上下会有一个空行，以开头，以------- End ------结尾。内容区第一行为此Log的代码调用位置。再下面为要输出的日志内容。 1. 快速集成 日志管理工具是kit库中实现的功能，所以引入kit库就默认集成了日志打印功能。具体kit库的引入方式请参见：kit引入文档 2. 使用方式 皓月日志的主要功能定义在Logcat类中，他提供两类功能：日志打印器的注册和统一的日志打印方法。下面我们分别介绍这两类功能的使用方式。 2.1. 注册日志打印器 皓月日志的设计初衷是为了方便不同子库的日志管理。为了区分不同的子库，我们采用了子库主包名作为子库id，在调用日志api时，会尝试分析调用代码所在类的包名，用来匹配不同子库打印器。为了提供子库定制化日志的能力，我们提供了日志打印器的注册功能。在日志打印前，我们强烈推荐你调用注册方法，用来初始化子库打印器。注册方法的入参分以下情况： 如果入参是ILogger对象，则此对象作为自定义的日志打印器。 如果入参是其他类型，则入参的包名将作为此子库的注册Id使用，如果后续日志调用是在此包名下，则会分配给此对象去处理 我们也想了很多如何方便的区分不同类库，例如使用固定日志对象处理，使用自定义资源文件处理等等。最终还是感觉使用包名作为区分id是最简单的方式，后续如果发现什么问题，再做修正和优化 注册方法的声明如下（在Logcat中）： /** * 注册一个logger * * 入参[entry]支持三种类型：主包下的对象、String类型的主包名、ILogger对象 * * 当为前两种类型时会自动使用[DefLogger]作为日志打印器，使用入参[entry]的包名作为打印器的id。 * 后续打印只有在此包名以及子包下的调用才会使用此打印器。 * * 当为ILogger对象时，则直接使用此对象作为日志打印器 * * [defTag]参数用来定义此打印器的默认tag，如果不进行设置，则会使用主包名的最后一段作为默认tag */ fun register(entry: Any, defTag: String? = null) 同时提供解注方法： /** * 解注一个logger * * 入参接收三种类型：主包下的对象、String类型的主包名、ILogger对象 * * 解注以后，对应logger将不能进行日志打印 */ fun unregister(entry: Any) 通常，注册日志打印器时，只需要提供当前子库的包名或者子库下的对象即可，而不需要提供ILogger实现。如果没有提供自定义的ILogger实现，则默认使用DefLogger，它的定义如下： /** * 默认的日志打印器 * * 提供标准的[ILogger]规定功能 * * 为了让打印内容更容易区分，做了如下打印内容优化： * 1. 会以[top]作为开头，并且在top中插入自定义tag，强化开头，[end]作为结尾 * 2. 打印的第二行会输出 '调用日志打印的代码位置'，方便代码回溯 * 3. 提供了headerInfo作为扩展信息，方便对日志添加扩展信息 * 4. 如果打印对象为集合或者map，则会采用json形式进行打印，方便集合等内容打印 * 5. 打印内容如果本身有换行，则使用两行进行打印，方便对齐打印内容 * * 根据上述第4条我们可以知道，日志打印对集合和map做了特殊功能处理，这里考虑为什么不对所有对象做json处理呢？ * 我们考虑到：1.你有可能想定制自己的toString进行日志内容管理。2. 你有可能是想看他的内存地址。3. 过于消耗性能。 * 所以我们只提供了针对特殊情况的特殊处理 */ class DefLogger(override var id: String) : ILogger 2.2. 开始打印日志 皓月日志主要是为日志打印做服务，简化日志的统一管理和接入。我们提供了常见的d、e、v、w、i的不同级别日志打印，同时提供了json方式的日志打印，分别对应Logcat的中的同名方法，如： // 打印日志 Logcat.d(\"I am log\") 在我们很多日志的应用场景中，其实不是所有位置都提前写好了要打印的日志。而是在出现问题时，需要在特定的代码处添加日志，方便查看此时的数据信息。例如： 方法sum提供参数加1的功能 fun sum(param: Int):Int { return param + 1 } // 得到的结果应该是4 sum(3) 这时候我们想查看sum方法是否得到的结果为4，通常我们如下修改： // 得到的结果应该是4 val result = sum(3) Logcat.d(result) //或者 Logcat.d(sum(3)) 可见，添加日志通常需要修改代码调用结构。针对这种情况，我们提供了对象扩展的日志方式： /** * 打印日志，级别：debug * * 默认使用当前调用的包名作为loggerSubId * * 更多定制参考[Logcat.d]、[Logcat] */ fun T.log(tag: String? = null): T 类似的其他级别日志方法为：logE()、logW()、logV()、logI()、logJson()。通过这种扩展方式的日志功能，上述情况我们可以如下实现： // 打印sum(3)的结果，并且返回此结果 sum(3).log() 通过这种方式，你可以方便的随时插入自己的日志，而不用修改调用结构。 扩展方法只是提供了一些简单的日志打印能力，如果要更多的定义日志打印，需要直接使用Logcat中的api： /** * 打印日志，级别：debug * * 如果msg == null 则会打印：\"log is null\" * 对日志内容的不同处理，可能会是不同的，因为真正的打印会分派到对应[loggerSubId]的打印器中。 * 如果没有自定义打印器，则会使用[DefLogger]作为默认的日志打印器。 * * [msg] 打印的日志信息 * [tag] 日志的tag信息 * [headerInfo] 日志的头信息 * [loggerSubId] 指定的日志器id，默认使用上层调用的包路径 */ @JvmStatic fun d(msg: Any?, tag: String? = null, headerInfo: String? = null, loggerSubId: String? = null) 还有类似的其他级别日志api。 2.3. 自定义trace打印数量 我们在打印日志的时候，默认会先打印当前日志调用的trace信息。 默认打印一层trace信息，也就是日志所在位置。 你也可以通过设置全局配置进行日志的trace数量设置，如下： // 一般在application中设置一次即可 Logcat.config().traceCount = 3 根据上面的设置，效果如下： 最后一行为触发日志打印的方法，整体顺序为调用堆栈顺序。 你也可以在单次日志打印时定义trace数量，如下 // 设置trace数量 Logcat.e(\"logTest\", traceCount = 2) // 设置trace数量 \"logTest\".log(traceCount = 2) 如果在调用日志打印时，不设置打印trace的数量，则默认使用全局config中的配置。 3.1. 更多自定义 你可以使用更多api做更多的功能性定制 3.2. 定义自己的日志打印器 例如你不满足DefLogger提供的日志功能，想自定义更好的日志效果，例如使用Logger做真正的日志输出，可以通过注册自定义ILogger的方式扩展打印方式。 3.2.1. 第一步：新建ILogger实例类 首先，你需要自己实现一个继承自ILogger的类，它是我们的打印api定义接口类，具体声明如下： /** * 日志标准接口 * * 提供打印器的id设置、是否可用、默认tag。提供日志打印（级别参见[Level]），日志json、xml格式打印 */ interface ILogger 在对应的log方法中转调到Logger中： override fun log(msg: Any?, level: ILogger.Level, tag: String?, headerInfo: String?, fixedMethodCount: Int?) { val p = when (level) { D -> Logger.DEBUG V -> Logger.VERBOSE I -> Logger.INFO W -> Logger.WARN E -> Logger.ERROR } Logger.log(p, tag, msg?.toString(), null) } 3.2.2. 第二步：注册自己的ILogger 将第一步实现的ILogger进行实例化，并注册到Logcat中： //第一步：初始化自定义ILogger val logger = LoggerProvider() logger.id = \"com.meili.moon.sdk.demo\" logger.defaultTag = \"Meili\" //第二步：注册自定义ILogger Logcat.register(logger) 注册完成后，com.meili.moon.sdk.demo包下的所有日志将使用新的日志打印器进行处理。 3.3. 定义日志的头信息 有时候在日志打印的时候，我们希望获取到上下文的代码调用位置。例如，在打印从网络返回的数据时，我们在日志中只会输出当前的打印位置，其实我们更多的时候是想打印出发起网络的代码位置，而不仅仅是网络日志的位置。皓月日志在打印日志时提供了headerInfo参数用来扩展日志打印信息，请参见Logcat类中的日志方法。同时Logcat中提供了两个便捷的工具方法用来获取指定的代码调用位置，如下： /** * 获取当前调用位置的日志头信息。 * * 获取到的格式如下：类名 + . + 调用方法名 + ( + 文件名称 + : + 行号)。 * 例如：MainActivity$onCreate$5.onClick (MainActivity.kt:30) * * 一般用来获取代码调用的日志格式信息，在打印日志是进行头信息设置 * * [fixedIndex] 修复的方法堆栈的调用index，默认只取调用此方法的位置 */ fun getLogInvokeInfo(fixedIndex: Int = 0): String /** * 获取当前调用位置的日志头信息。 * * 获取到的格式如下：类名 + . + 调用方法名 + ( + 文件名称 + : + 行号)。 * 例如：MainActivity$onCreate$5.onClick (MainActivity.kt:30) * * 一般用来获取代码调用的日志格式信息，在打印日志是进行头信息设置 * * [invokePath] 目标方法的调用路径，例如：com.meili.moon.sdk.log.Logcat.d，不要有方法的括号 */ fun getLogInvokeInfo(invokePath: String): String? 通过上面的方法，可以方便的获取到当前代码的位置信息，并结合我们的默认日志打印器DefLogger，在日志中进行打印，如下： fun log() { //获取当前代码位置，并传给log1 log1(Logcat.getLogInvokeInfo()) } fun log1(headerInfo: String?) { //打印日志，并添加头信息 Logcat.d(\"TestLog.log()\", headerInfo = headerInfo) } 最终打印的日志如下： TestLog.log (TestLog.kt:15)就是我们添加的头日志信息，至此我们就可以方便快捷的添加多个可能需要关注的代码位置信息。当然你也可以添加其他的头信息。 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-11-06 17:50:42 "},"db/":{"url":"db/","title":"数据持久化-DB","keywords":"","body":"DB文档 Db数据库是为存储在SQLite中的数据提供面向对象的接口，你只需要创建Java数据对象即可为你创建对应的数据库，可以让你更容易的使用SQLite数据库，你不需要编写SQL语句就可以完成对数据库的操作。 1. 快速集成 1.1. Gradle implementation \"com.meili.moon.sdk:db:x.x.x\" 1.2. 初始化 在application的onCreate()方法中进行初始化环境 class DemoApp : Application() { override fun onCreate() { super.onCreate() MoonDB.init(this) } } 注：如果项目中引入了整体皓月库，则不需要在单独初始化。 2. 快速使用 2.1. 创建数据库 val mDBImpl = DBImpl.getInstance(this) 如果你要设置数据库的路径，自定义数据库的名称可以参考配置 2.2. 创建表 2.2.1. 创建存储对象实体类 使用皓月数据库存储数据，只需要在你存储的数据类前面声明@Table注解 @Table class Person { //id为主键 @Column(isId = true) var id: String = \"\" var name: String = \"\" } 更多注解注解 2.2.2 新建数据库表 声明完实体类之后，通过save()可以创建出数据库表同时保存一条数据。 val user = Person() user.id = \"1\" user.name = \"mljr\" mDBImpl.table.save(user) 这样一个Person的表就新建起来了。 创建之后格式是这样的 ID NAME ---------- ---------- 1 mljr 2.2.3. 添加数据 上面我们通过save()创建出来数据库表的同时添加了一条数据，如果我们想要继续添加数据，可以继续调用save() val user = Person() user.idd = \"2\" user.name = \"Paul\" mDBImpl.table.save(user) val user = Person() user.id = \"3\" user.name = \"Allen\" mDBImpl.table.save(user) 使用上面的语句之后将在Person表中创建两个记录 ID NAME ---------- ---------- 1 mljr 2 Paul 3 Allen 2.3. 更新数据 3.3.1 save()方式更新 save()不仅能添加数据，可以用来更新一个实体，如果插入主键在数据库已经存在的数据，即视为更新这条数据。 下面的语句是更新id=2的人员的名字为Peter val user = Person() user.id = \"2\" user.name = \"Peter\" mDBImpl.table.save(user) 使用上面的语句之后将在Person表中更新一个记录 ID NAME ---------- ---------- 1 Paul 2 Peter 3 Allen 添加和更新数据的规则是 1. 如果实体类的主键不为空的情况下 如果已经存在，则进行数据更新 如果不存在，则进行数据插入 2.如果实体类的主键为空的情况下 如果id为自增长，插入数据后，赋值id到entity中 如果id不是自增长，则插入失败 注： id要为Long类型 2.3.2. Update()方式更新 用Update()修改已有的记录，可以使用WHERE条件限定来查找选定行，否则所有的行都会被更新。例： 如果我们要将id为3的员工姓名更新为Kate 但是在框架中我们只要这么做就可以了 mDBImpl.table.update(Person::class,Pair(\"name\",\"Kate\")){ and(\"id\", \"=\", \"3\") } 更多筛选条件where条件语句 如果更新某一个实体推荐使用save() 2.4. 查询 2.4.1. 查询所有数据 val personList = mDBImpl.table.get(Person::class) 2.4.2. 按照ID查询 val person = mDBImpl.table.get(\"3\",Person::class) 2.4.3. 按照条件查询 查找id等于1的人员 val person = mDBImpl.table.get(Person::class) { and(\"id\", \"=\", \"1\") } 更多筛选where条件语句 更多查询高级查询 2.5. 删除数据 删除表中已有的数据，可以使用WHERE条件限定来删除选定行。 如果我们要删除id是1岁的用户,但是在框架中我们只要这么做就可以了 mDBImpl.table.delete(Person::class){ and(\"id\", \"=\", \"1\") } 更多筛选where条件语句 2.6. 关闭数据库 mDBImpl.close() 2.7. 删除数据库 mDBImpl.dropDB() 2.8. 删除指定的表 mDBImpl.dropTable(PersonModel::class) Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-09-26 10:03:48 "},"db/注解.html":{"url":"db/注解.html","title":"注解","keywords":"","body":"1. 注解 使用皓月数据库存储数据，我们需要根据数据库表的字段定义实体类，只需要在你存储的数据类前面声明@Table注解 例如： @Table class Person { //id为主键 @Column(isId = true) var id: String = \"\" var name: String = \"\" } 我们定义数据库表时，实体类上相关注解说明： 1.1. 实体@Table注解 /**table名称，默认使用类名*/ val value: String = \"\", /**创建完表后执行的操作*/ val onCreated: String = \"\", /**设置table中的property是否必须有注解才认为是数据库字段*/ val propertyWithAnnotation: Boolean = false 注：自动增长时ID类型需要Long 1.2. 属性注解@Column /**列名称，默认使用字段名称*/ val value: String = \"\", /**列属性，默认没有属性*/ val property: String = \"\", /**当前字段是否是id，默认不是id*/ val isId: Boolean = false, /**当前字段是否自增长，默认自增长*/ val autoGen: Boolean = false, /**是否忽略当前属性*/ val ignore: Boolean = false Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-09-26 10:03:48 "},"db/配置.html":{"url":"db/配置.html","title":"配置","keywords":"","body":"1. 配置 如果需要我们可以做一些个性化的配置，比如指定数据库的位置，数据库的名称，数据库的版本号等信息，我们可以如下这么做去配置数据库的相关信息。 val config = IDB.Config .newBuilder() /**数据库的位置*/ .setDbDir(File(\"\")) /**数据库名称*/ .setDbName(\"mljr.db\") /**数据库是否允许使用事务*/ .setAllowTransaction(true) /**数据库打开监听*/ .setDbOpenListener(object : IDB.DbOpenListener { override fun onDbOpened(db: IDB) { } }) /**数据库升级监听*/ .setDbUpgradeListener(object :IDB.DbUpgradeListener{ override fun onUpgrade(db: IDB, oldVersion: Int, newVersion: Int) { } }) /**数据库创建监听*/ .setTableCreateListener(object :IDB.TableCreateListener{ override fun onTableCreated(db: IDB, table: String) { } }) .build() val mDBImpl = DBImpl.getInstance(this, config) 注：如果不配置可以直接生成默认的数据库，如果没有特殊要求可以不配置 val mDBImpl = DBImpl.getInstance(this, config) Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-09-26 10:03:48 "},"db/WHERE条件语句.html":{"url":"db/WHERE条件语句.html","title":"WHERE条件语句","keywords":"","body":"1. WHERE条件语句 SQLite的WHERE子句用于指定一个表或者多个表中获取数据的条件 如果满足给定的条件，即为真，则从表中返回特定的值，您可以使用WHERE子句来过滤记录，只获取需要的记录。WHERE子句不仅可在SELECT语句中，它也可以用在UPDATE，DELETE语句中。 以下的查询都是基于 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 1.2. AND运算符 AND运算符允许在一个 SQL 语句的 WHERE 子句中的多个条件的存在,使用 AND 运算符时，只有当所有条件都为真（true）时，整个条件为真（true） 下面的例子是请求 AGE 大于等于 25 且工资大于等于 65000.00 的所有记录 在框架中我们应该这么做 mDBImpl.table.update(COMPANY::class,Pair(\"age\",\"28\")){ and(\"AGE\", \">=\", \"25\") and(\"SALARY\", \">=\", \"65000\") } 查询出来的结果 ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 AND的参数解析 * @param columnName 表中的字段名称 * @param op 操作符号 * @param value column具体的值 类比SQL语句 SELECT * FROM COMPANY WHERE AGE >= 25 AND SALARY >= 65000 1.3. OR运算符 OR 运算符也用于结合一个 SQL 语句的 WHERE 子句中的多个条件。使用 OR 运算符时，只要当条件中任何一个为真（true）时，整个条件为真（true）。 下面的例子是请求 AGE 大于等于 25 或工资大于等于 65000.00 的所有记录 在框架中我们应该这么做 mDBImpl.table.update(COMPANY::class,Pair(\"age\",\"28\")){ or(\"AGE\", \">=\", \"25\") or(\"SALARY\", \">=\", \"65000\") } 查询出来的结果 ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 OR的参数解析 * @param columnName 表中的字段名称 * @param op 操作符号 * @param value column具体的值 类比SQL语句 SELECT * FROM COMPANY WHERE AGE >= 25 OR SALARY >= 65000; 2 op 操作符号 OR和AND都需要op操作符配合完成查询 <> 不等于 > 大于 >= 大于等于 /> BETWEEN 在范围之间,直接使用BETWEEN，不要带AND LIKE 搜索,like可使用通配符( _ 只有一个)（ %或者* 任意多个），例如LIKE '_K%'代表第二个字母是K的 IS NOT NULL 不为空 IS NULL 为空 IN () 在例举之中 NOT IN () 不在例举之中不支持NOT IN Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-09-26 10:03:48 "},"db/高级查询.html":{"url":"db/高级查询.html","title":"高级查询","keywords":"","body":"1. 高级查询 1.1. Limit子句 SQLite 的 LIMIT 子句用于限制由 SELECT 语句返回的数据数量，一般与OFFSET子句一起使用时的语法。 实例： 比如说查找年龄是32岁的Person从第三位开始提取 3 个记录 val selector = mDBImpl.table.selector(PersonModel::class) { limit = 3 offset = 0 where { and(\"age\", \"=\", \"32\") } } selector.findAll() 详细例子 1.2. Order By SQLite 的 ORDER BY 子句是用来基于一个或多个列按升序或降序顺序排列数据。 实例： 你想要结果按照 SALARY 升序排序： 但是在框架中我们只要这么做就可以了 val List = mDBImpl.table.selector(PersonModel::class) .orderBy(ISelector.OrderBy(\"SALARY\", false)) .findAll() 详细例子 1.3. Group By SQLite 的 GROUP BY 子句用于与 SELECT 语句一起使用，来对相同的数据进行分组。 实例： 如果你想要按照名字分组 但是在框架中我们只要这么做就可以了 val List = mDBImpl.table.selector(PersonModel::class) .groupBy(\"Name\") { build() } .findAll() 详细例子 1.4. Having HAVING 子句允许指定条件来过滤将出现在最终结果中的分组结果。 实例： 它将显示年龄等于32 的所有记录： 在我们的代码中是 val List1 = mDBImpl.table.selector(PersonModel::class) .groupBy(\"Name\") { having { and(\"age\", \"=\", \"32\") } } .findAll() 详细例子 1.5. 查找 我们提供给你查找结果是可以查询出符合条件的所有数据，也提供直接筛选出第一条数据便利的API findAll() 查找出所有的数据 findFirst() 查找出第一条数据 1.5.1. 查找特定的字段 默认查询符合条件的所有字段，如果你想要查找某个特定的字段所有数据，你可以这样定义： val List1 = mDBImpl.table.selector(PersonModel::class) { select(listOf(\"name\")) } .findAll() Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-09-26 10:03:48 "},"db/Limit.html":{"url":"db/Limit.html","title":"Limit","keywords":"","body":"Limit 子句 SQLite 的 LIMIT 子句用于限制由 SELECT 语句返回的数据数量。 LIMIT 子句与 OFFSET 子句一起使用。 以下的查询都是基于 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面是一个实例，可能需要从一个特定的偏移开始提取记录，从第三位开始提取 3 个记录： val selector = mDBImpl.table.selector(PersonModel::class) { limit = 3 offset = 2 } selector.findAll() 这将产生以下结果： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 类比SQL语句 SELECT * FROM COMPANY LIMIT 3 OFFSET 2; Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-09-26 10:03:48 "},"db/OrderBy.html":{"url":"db/OrderBy.html","title":"OrderBy","keywords":"","body":"Order By 子句 SQLite 的 ORDER BY 子句是用来基于一个或多个列按升序或降序顺序排列数据。您可以在 ORDER BY 子句中使用多个列。确保您使用的排序列在列清单中。 以下的查询都是基于 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面是一个实例，它会将结果按 SALARY 升序排序： val List = mDBImpl.table.selector(COMPANY::class) .orderBy(ISelector.OrderBy(\"SALARY\", false)) .findAll() 这将产生以下结果： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 7 James 24 Houston 10000.0 2 Allen 25 Texas 15000.0 1 Paul 32 California 20000.0 3 Teddy 23 Norway 20000.0 6 Kim 22 South-Hall 45000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 类比SQL语句 SELECT * FROM COMPANY ORDER BY SALARY ASC; Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-09-26 10:03:48 "},"db/Group By.html":{"url":"db/Group By.html","title":"GroupBy","keywords":"","body":"Group By SQLite 的 GROUP BY 子句用于与 SELECT 语句一起使用，来对相同的数据进行分组。 在 SELECT 语句中，GROUP BY 子句放在 WHERE 子句之后，放在 ORDER BY 子句之前。 以下的查询都是基于 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 如果你想要查找薪水按照名字分组 val List = mDBImpl.table.selector(COMPANY::class) { select(listOf(\"SALARY\")) } .groupBy(\"Name\") { build() } .findAll() 结果如下 NAME SALARY ---------- ---------- Paul 20000.0 Allen 15000.0 Teddy 20000.0 Mark 65000.0 David 85000.0 Kim 45000.0 James 10000.0 类比SQL语句 SELECT SALARY FROM COMPANY GROUP BY NAME Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-09-26 10:03:48 "},"db/Having.html":{"url":"db/Having.html","title":"Having","keywords":"","body":"Having HAVING 子句允许指定条件来过滤将出现在最终结果中的分组结果。 WHERE 子句在所选列上设置条件，而 HAVING 子句则在由 GROUP BY 子句创建的分组上设置条件。 以下的查询都是基于 COMPANY 表有以下记录： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 1 Paul 32 California 20000.0 2 Allen 25 Texas 15000.0 3 Teddy 23 Norway 20000.0 4 Mark 25 Rich-Mond 65000.0 5 David 27 Texas 85000.0 6 Kim 22 South-Hall 45000.0 7 James 24 Houston 10000.0 下面是一个实例，它将显示名称等于kim的所有记录： val List1 = mDBImpl.table.selector(PersonModel::class) .groupBy(\"Name\") { having { and(\"name\", \"=\", \"Kim\") } } .findAll() 这将产生以下结果： ID NAME AGE ADDRESS SALARY ---------- ---------- ---------- ---------- ---------- 6 Kim 22 South-Hall 45000.0 类比 SQL 语句 SELECT * FROM COMPANY GROUP BY name HAVING count(name) Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-09-26 10:03:48 "},"cache/":{"url":"cache/","title":"本地缓存管理-Cache","keywords":"","body":"皓月缓存库 皓月缓存库是基于数据库的方式通过简便的调用方式实现缓存的快速读取与插入操作，如果超过缓存库的容量，缓存库采用的策略是LRU。 1.快速集成 1.1 Gradle api \"com.meili.moon.sdk:cache:x.x.x\" 1.2 初始化 在application的onCreate()方法中进行初始化环境 class DemoApp : Application() { override fun onCreate() { super.onCreate() MoonCacheImpl.init(this) } } 注：如果项目中引入了整体皓月库，则不需要在单独初始化。 2.使用方式 缓存库的缓存方式分为两种，一种是缓存字符串，一种是缓存文件。 2.1. Api缓存 我们在使用缓存时，通常是要将需要缓存的内容存入，需要读取缓存的时候去读取。 val cache = MoonCacheImpl.getCache() //将内容缓存起来 cache.put(\"cache\",\"缓存的内容\") //读取缓存的内容 val cache = cache.getValue(\"cache\") 2.2. 文件缓存 val fileCache = MoonCacheImpl.getFileCache() //将文件缓存起来 fileCache.put(\"fileCache\", File(filePath)) //读取缓存的文件 val cache = fileCache.getValue(\"fileCache\") 3. 高级特性 除了基本的使用，还包括配置缓存的最大条数，文件缓存的最大磁盘空间，清除缓存等功能 3.1 配置最大缓存数，最大的磁盘空间 配置不是必须的，如果不配置，缓存库会为你提供默认的缓存数，默认的缓存数为5000，文件缓存的最大磁盘空间为100M，如果你觉得并不适合你的程序，我们提供了自定义设置，如下： cache.configGlobal(object : DiskCache.Config { /**缓存最大条数*/ override var cacheMaxCount: Int = 500 /**文件缓存的最大磁盘空间，单位：字节*/ override var cacheMaxFileSize: Long = 10 * 1024 * 1024L }) 3.2 通过key清除缓存 我们在存储缓存的时候是通过键值对方式存储，我们也可以通过key去删除这条缓存 val cache = MoonCacheImpl.getCache() cache.remove(\"cache\") 3.3 清除缓存 缓存分为两类缓存，一类是文件缓存，一类是字符串缓存，如果你想单独清除哪一类的缓存，可以使用clear() val fileCache = MoonCacheImpl.getFileCache() //清除文件的缓存 fileCache.clear() val cache = MoonCacheImpl.getCache() //清楚字符串的缓存 cache.clear() 3.4 清除全部缓存 在我们开发项目时，如果你想清楚全部缓存可以使用clearAll()，无论哪个谁调用都是清除全部缓存。 val fileCache = MoonCacheImpl.getFileCache() //清除全部缓存 fileCache.clearAll() val cache = MoonCacheImpl.getCache() //清楚全部缓存 cache.clearAll() Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-09-26 10:03:48 "},"http/http快速接入.html":{"url":"http/http快速接入.html","title":"网络请求-Http","keywords":"","body":"皓月网络库 皓月网络库是使用kotlin语言实现，基于okhttp3封装的网络框架，拥有以下特点： 支持Http/Https协议/自定义Https证书认证 支持同步/异步请求 提供基于RequestParam定制化的请求体验 提供基于泛型的数据集解析能力。 提供批量定制化参数能力。 提供快速缓存接入。 提供UI绑定的请求回收机制 提供请求参数以及返回结果的快速拦截 提供网络请求的通用设置 自定义线程池，使用自己的线程池管理网络请求 1. 快速集成 1.1. Gradle api \"com.meili.moon.sdk:http:x.x.x\" 1.2. 初始化 在application的onCreate()方法中进行初始化环境 class DemoApp : Application() { override fun onCreate() { super.onCreate() HttpSdk.init(this) } } 注：如果项目中引入了moon_sdk_app，则不需要在单独初始化。 2. 使用方式 2.1 简单调用 在我们请求网络时，有时我们只是简单的访问服务器的一个接口，为此我们提供最简便的调用，例如下面是一个简单的get请求： 2.1.1. get请求 httpGet{ val param = DefHttpParams() //设置Url 例如“www.mljr.com/example/mock” param.setUrl(\"xxx\") //设置请求头 param.addHeader(\"header\",\"xxx\") //设置参数 param.addParam(\"param\",\"xxx\") params = param //定义解析的返回数据类型的model onSuccess{ } } 2.1.2. post请求 post请求同理get请求 httpPost{ val param = DefHttpParams() params = param onSuccess{ } } 框架会根据你提供的model自动帮你解析数据返回 2.2. 推荐接入方式 在我们做网络请求时，通常我们喜欢把通用的配置提取出来在application中全局配置，例如：请求头和通用url的设置，这样以后你的每个请求都不需要在去做重复的操作，我们推荐以下的接入方式，例如： val config = Config.newBuilder() .setBaseUrl(\"http://www.mljr.com/\") .addHead(\"mljr\",\"mljr\") .build() HttpImpl.config(config) 关于全局配置更多的信息可以参考配置 接下来为了使我们的每一个请求都更加清晰明了，我们建议对于每一个请求都新建一个Params的类，继承DefHttpParams，我们可以在类中设置url,参数，拼接路径等操作,例如我们想要做一个登录的操作如下示例： @HttpRequest(\"mock/login\") class LoginParams() : DefHttpParams() { val username = \"mljr\" val password = \"mljr123\" } httpGet { val param = LoginParams() params = param onSuccess { } onError { errorMessage, exception -> } } 如果想更多了解配置参数的问题可以参考 参数的详情 如果想更多了解配置请求头的的问题可以参考 请求头的详情 2.3. 另一种接入方式 我们在做网络请求时，如果你在一个app中有几类BaseUrl的请求，而全局config只能配置一个统一的，不满足需求，如果使用每一个请求都要重新设置，又大大的增加了开发量，这时候我们推荐你用另外一种继承的方式去实现请求。更多接入 3. 交互 在我们做网络请求时，通常如果你不想在每次请求前都做打开progress，请求完成式关闭progress的操作，或者在每次请求时都需要添加一些通用的操作，可以在你的base页面实现 UEHttpHolder接口，添加UI交互 interface UEHttpHolder : IDestroable { /**显示一个error的message，[ueType]为发起请求是定义的type*/ fun showUEErrorMessage(msg: String?, ueType: Int) /**显示一个加载的进度，[ueType]为发起请求是定义的type*/ fun showUEProgress(msg: String?, ueType: Int) /**取消一个加载的进度，[ueType]为发起请求是定义的type*/ fun dismissUEProgress(ueType: Int) /**当前是否可交互*/ var isUEnable:Boolean } 4. 同步请求 我们在做网络请求时，如果你需要同步调用，可以使用如下方式： 4.1. 同步调用get方式 val param = DefHttpParams() param.setUrl(\"xxx\") param.addHeader(\"header\",\"xxx\") param.addParam(\"param\",\"xxx\") var result = HttpSdk.http().getSync(param, xxxModel::class.java) 如果请求返回类型是List类型用如下方式： val param = DefHttpParams() var result = HttpSdk.http().getSyncList(param, xxxModel::class.java) 4.2. 同步调用post方式 val param = DefHttpParams() var result = HttpSdk.http().postSync(param, xxxModel::class.java) 如果返回类型是List类型用如下方式： val param = DefHttpParams() var result = HttpSdk.http().postSyncList(param, xxxModel::class.java) 5. 其他 如果想了解更多个性化配置，请参考个性化配置 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2020-04-10 15:41:21 "},"http/配置.html":{"url":"http/配置.html","title":"配置","keywords":"","body":"1. 个性化配置 如果需要我们可以做一些个性化配置，但是所有的配置项都不是必须的，但是做一些个性化的配置，可以减少你的每个请求的代码量。 我们可以在application中设置全局的通用配置,例： val config = Config.newBuilder() //添加解析器 .addParser(DefHttpRespParser()) //设置全局的url .setBaseUrl(\"http://mljr.com/\") //添加全局通用请求头 .addHead(\"mljr\",\"test\") //添加全局通用转换器 .addExtraConvert(ApiResponseExtraParser()) //添加当有相同request发起时的策略方式 .addStrategy(IHttp.SameRequestStrategy.CANCEL_PRE_REQUEST) .build() HttpImpl.config(config) 2. 详细配置 2.1. 配置解析器 解析器是用来解析服务端返回的json数据的，就是把服务器的响应转化为本地预期的结果的一个工具，你可以自己设置一套符合你自己规则的解析器，也可以用框架默认实现的，如果不配置，会使用框架默认的解析器。如果没有特殊业务要求，不推荐配置。详情 val config = Config.newBuilder() .addParser(DefHttpRespParser()) .build() HttpImpl.config(config) 2.2. 配置通用的URL 配置全局的URL，如果不配置，就需要在每个请求的时候写上全路径的URl，如果配置通用的BaseUrl，每次请求只要拼接后面的字符串就好。 val config = Config.newBuilder() .setBaseUrl(\"http://mljr.com/\") .build() HttpImpl.config(config) 2.3. 配置全局的header 配置全局的请求头，更多关于头的信息请参考详情 val config = Config.newBuilder() .addHead(\"mljr\",\"mljr\") .build() HttpImpl.config(config) 2.4. 配置全局的转换器 在解析服务器返回的数据时，需要和服务器统一返回Json格式，转换器就是解析掉最外层统一的json格式，将不通用的json格式返回到系统的解析器去解析，我们推荐配置全局的转换器,这样就不需要每次写解析model的时候都带上通用部分了，更多关于转换器的信息请参考详情 val config = Config.newBuilder() .addExtraConvert(ApiResponseExtraParser()) .build() HttpImpl.config(config) 2.5. 配置相同request发起请求时的策略方式 两种策略方式 CANCEL_PRE_REQUEST策略模式：当有相同两个request的时候，取消前一个request CANCEL_CURR_REQUEST策略模式：当有相同两个request的时候，取消当前发起的request 用法如下 ``` val config = Config.newBuilder() //添加当有相同request发起时的策略方式 .addStrategy(IHttp.SameRequestStrategy.CANCEL_PRE_REQUEST) .build() HttpImpl.config(config) ``` 更多特性高级特性 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-09-11 10:29:10 "},"http/项目中接入.html":{"url":"http/项目中接入.html","title":"更多接入","keywords":"","body":"1. 在项目中接入 在项目中接入,我们还提供一套更加灵活的接入方式，不想在每次请求都配置同样的请求头，频繁的设置url，你可以选择全部配置的方式，也可以选择继承的方式，自定义通用的解析parser，response，params,builder,如果两种方式都采用，继承的方式优于全局配置的方式。 用继承实现的好处是，如果你app中有几类BaseUrl不同的请求，用全局配置的方式只能定义一种，而采用继承的方式就是你有几类BaseUrl,你定义几个请求params即可。 1.1. 配置ParamsBuilder 首先配置添加固定的请求头的Builder,继承SdkHttpParamsBuilder，自定义的Builder主要是用来添加header和基础的BaseUrl, class ApiCustomParamBuilder :SdkHttpParamsBuilder(){ //添加额外的头信息，和全局配置并行 override fun getHeaders(): MutableMap { val headers = super.getHeaders() headers.apply { put(\"customHeader\",\"customHeaderInfo\") } return headers } override fun getDefaultHost(): String { //配置服务器的地址，这个配置优于全局配置 return \"https://www.mljr.com/\" } } 1.2. 配置ResponseParser 自定义解析器Parser,需要继承SdkHttpRespParser，自定义的parser和全局配置的convert是一个概念，都是用于去掉通用的外壳。 open class ApiCustomResponseParser : SdkHttpRespParser() { override fun parseCommonData(result: String?, response: IHttpResponse) { //自定义解析的结构体 例： //当前接口的业务code val json = JsonHelperImpl.parseObject(result) response.state = json.getInteger(\"status\") ?: 0 response.message = json.getString(\"msg\") ?: \"\" response.data = json.getString(\"data\") } } 1.3. 配置response 自定义response 继承SdkHttpResponse，作用是将刚刚定义的parser设置进去。 class ApiResponse(override var requestParams: IRequestParams.IHttpRequestParams) : SdkHttpResponse() { override var parser: IResponseParser = ApiCustomResponseParser() } 1.4. 配置param 自定义params 继承SdkHttpRequestParams，用于设置response和builder. open class ApiRequestParam(url: String = \"\") : SdkHttpRequestParams(url) { override var response: IHttpResponse = ApiResponse(this) override fun getDefaultParamBuilder(): IParamsBuilder { return ApiCustomParamBuilder() } } 1.5. 定义实际param 定义完四个基本的配置之后开始实际调用，以后你的每个请求都自定义一个params 继承刚刚定义的ApiRequestParam 例： //url路径通过注解的方式配置 @HttpRequest(\"mock/example/one\") class CustomOneParams : ApiRequestParam(){ var userName: String? = null var password: String? = null } 通过HttpRequest的注解可以直接设置URL，可以设置全路径URL，也可以设置前面配置的通用域名之后的路径。 1.6. 开始调用 1.6.1 get的异步调用方式 httpGet{ var param = CustomOneParams() param.userName = \"8888\" param.password = \"mljr.com\" params = param onSuccess { } } 1.6.2 post的异步调用方式 httpPost{ var param = CustomOneParams() params = param onSuccess { } } 高级特性 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-09-11 10:29:10 "},"http/头.html":{"url":"http/头.html","title":"头","keywords":"","body":"1.头 头分为请求头和响应头，开发者可以自己设置自定义的请求头，响应头由框架自动帮你进行了处理。 一些自定义请求头的设置，可以通过全局配置，也可以为某个请求单独添加或者设置。 1.1. 请求头 1.1.1. 全局配置： val config = Config.newBuilder() .addHead(\"head1\",\"test1\") .addHead(\"head2\",\"test2\") .build() 1.1.2. 单独指定： httpGet { val param = CustomParams() param.addHeader(\"head3\",\"header3\") params = param onSuccess> { } } Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-09-11 10:29:10 "},"http/参数.html":{"url":"http/参数.html","title":"参数","keywords":"","body":"1. 参数 参数是指为某个请求单独设置请求参数和在路径中拼接自定义的path 一般的请求分为get请求和post请求，get请求通常以?key=value&key=value的形式携带的，而post请求一般通过RequestBody以流的形式发送。 1.1. get请求 对于get请求，下面这段代码，最终url是“https://www.mljr.com/mock/example/four?username=http&password=mljr” @HttpRequest(\"https://www.mljr.com/mock/example/four\") class CustomListParams() : DefHttpParams() { val username = \"http\" val password = \"mljr\" } httpGet { val param = CustomListParams() onSuccess> { } } 1.2. post请求 对于post类请求，下面这段代码最终url是“https://www.mljr.com/mock/example/four”但requestBody中会发送username=http&password=mljr @HttpRequest(\"https://www.mljr.com/mock/example/four\") class CustomListParams() : DefHttpParams() { val username = \"http\" val password = \"mljr\" } httpPost { val param = CustomListParams() onSuccess> { } } 对于post和get的方式声明参数的方式是一样的，只是如果你用get方式请求，框架会帮你拼接到后面，如果你是post请求框架会帮你将参数封装成RequestBody形式发送出去。 1.3. 请求时添加参数 你可以在请求时添加自己的参数，事例： httpPost { val param = CustomParams() param.addParam(\"password\",\"mljr.com\") params = param onSuccess> { } } 1.4. 在路径中拼接path 在开发中我们会遇到拼接path的情景，我们只要在参数上注解@HttpPath，value为key,然后key占位到url中，value设置为实际的值，框架为自动帮你解析替换。 下面这段代码最终url是“https://www.mljr.com/mock/example/four?username=http&password=mljr” @HttpRequest(\"mock/{users}/four\") class CustomListParams() : DefHttpParams() { @HttpPath(value = \"users\") val user:String = \"\" val username = \"http\" val password = \"mljr\" } httpGet { val param = CustomListParams() param.user=\"example\" onSuccess> { } 你也可以在请求的时候添加，默认添加在末尾,但是我们不推荐这种方式 httpGet { val param = CustomListParams() param.addParam(\"param\",\"xxx\") onSuccess> { } } Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-09-11 10:29:10 "},"http/高级特性.html":{"url":"http/高级特性.html","title":"高级特性","keywords":"","body":"1. 高级特性 1.1. 开启Gzip 如果需要开启Gzip，需要自定义请求参数，在类中覆写isGzip()方法，返回true. 例： @HttpRequest(\"mock/example/one\") class CustomOneParams : ApiRequestParam(){ override fun isGzip(): Boolean { return true } } 1.2. 设置重试机制 框架中默认实现一套重试机制，默认实现的重试机制为最大尝试是次数为2次, 自定义自己的重试机制 实现IRetryHandler接口，定制符合自己规范的重试机制。 interface IRetryHandler { /** * 是否可以重试 * @param requestInstance 请求重试的实体 * @param throwable 失败时发生的错误 * @return true可以重试，false不能重试 */ fun retry(requestInstance: ReqIns, throwable: Throwable): Boolean /**获取最大重试次数*/ fun getMaxTimes(): Int /**获取当前重试次数*/ fun getTimes(): Int } 然后在params中设置,例： @HttpRequest(\"mock/example/one\") class CustomOneParams : ApiRequestParam(){ override fun getRetryHandler(): IRetryHandler? { return CustomRetryHandler() } 1.3.设计网络追踪器 如果你想追踪网络请求，设置网络请求日志追踪接口，实现IRequestTracker接口，然后设置在你的params中 @HttpRequest(\"mock/example/one\") class CustomOneParams : ApiRequestParam(){ override fun getTracker(): IRequestTracker? { return CustomRequestTracker() } 1.4.获取返回数据集的拦截处理器 如果你想获取最原始的response信息，可以实现IResponseInterceptor接口 interface IResponseInterceptor { fun intercept(resp: IResponse) } 然后设置在params中 @HttpRequest(\"mock/example/one\") class CustomOneParams : ApiRequestParam(){ override fun getResponseInterceptor() = CustomResponseInterceptor() } 1.5.设置request的过滤器 如果想要在请求之前和请求之后处理params，实现IRequestFilter interface IRequestFilter { //isBeforeRequest 为true时 为请求之前调用，false为请求完成时调用 fun filter(param: IRequestParams, isBeforeRequest: Boolean) } 然后设置在Params中 @HttpRequest(\"mock/example/one\") class CustomOneParams : ApiRequestParam(){ override fun getRequestFilter(): = CutomRequestFilter(); } 1.6. 设置https处理类 设置https处理类，实现SSLSocketFactory，设置在params中 @HttpRequest(\"mock/example/one\") class CustomOneParams : ApiRequestParam(){ override fun getSSLSocketFactory(): SSLSocketFactory? = CustomSSLSocketFactory() } 其他特性 取消 缓存 下载 转换器 解析器 异常和失败 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-09-11 10:29:10 "},"http/解析器.html":{"url":"http/解析器.html","title":"解析器","keywords":"","body":"1. 解析器 1.1. 定义 解析器就是把服务器的响应转化为本地预期的结果的一个工具，你可以自己设置一套符合你自己规则的解析器，也可以用框架默认实现的，如果不配置，会使用框架默认的解析器。如果没有特殊业务要求，不推荐配置。 1.2. 作用 Parser的作用是将服务器返回的数据转换为本地数据，可以包装业务的成功与否的结果，简化了自己解析json的过程，带来的好处是不用在主线程解析数据。 1.3. 接口定义 IResponseParser是一个接口，只需要把response的响应读取出来，并转化为指定的类型对象，如果对象是集合返回List即可，如果是一个对象，则将对象加入到list集合中返回即可。 interface IResponseParser { /**解析信息*/ fun parse(response: IHttpResponse, dataType: Class): List? } 1.4. 参数释义 1.4.1. DataType 泛型DataType是用来限定业务成功时的数据类型，例如开发者登录时，DataType就为LoginInfo 1.4.2. response 参数response为请求对应的响应，包含了response返回的数据等信息。 1.4.3. List 返回数据List，如果对象是集合返回List即可，如果是一个对象，则将对象加入到list集合中返回即可。 2. 全局配置和单独使用 如果开发者的多有请求的返回结果都是有规则且规则相同，那么Parser就配置成全局的解析器，避免在每一个请求都需要配置一个converter，如果未配置则默认使用框架默认的DefHttpRespParser val config = Config.newBuilder() .addParser(DefHttpRespParser()) .build() 如果只有某几个请求的结果和不符合全局解析器的规则，那么可以单独指定某个请求的解析器。 httpGet { val param = CustomListParams() param.addParser(DefHttpRespParser()) params = param onSuccess> { } } 注：所有没有单独指定解析器的请求将自动使用配置的解析器，如果单独指定则仅仅使用单独的解析器，如果都没有则使用默认的解析器。 2.1 优先级 单独配置 > 全局配置 > 默认配置 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-09-11 10:29:10 "},"http/转换器.html":{"url":"http/转换器.html","title":"转换器","keywords":"","body":"1. 转换器 1.1. 定义 在解析服务器返回的数据时，需要和服务器统一返回Json格式，这个在开发中经常遇到。一般服务器也不会随便返回Json格式给前端，否则前端解析时将会非常麻烦。(所以这里的数据结构需要前端和服务端约定一个固定的格式)，如果你不想自己完全去实现解析操作，可以设置继承converter，解析掉统一的外壳，将符合规范的返回回来。 1.2.作用 Converter作用是在默认解析器的基础上提供通用的转换功能，省去了你自己重新写一个解析器的麻烦。 1.3. 接口定义 Converter是一个接口，只需要把返回的result字符串解析，然后包装成response即可。 interface IResponseExtraConvert { /**去掉统一返回的Json格式*/ fun convertCommonData(result: String?, response: IHttpResponse) } 1.4. 参数释义 result为服务端返回的原数据 response为我们接下来需要使用的数据对象。 2. 全局配置和单独使用 如果开发者的所有请求的返回结果都是有规则且规则相同，那么Converter可以配置成全局转换器，避免在每一个请求都需要配置一个Converter的麻烦 val config = Config.newBuilder() .addExtraConvert(ApiResponseExtraConvert()) .build() 如果只有某几个请求的结果和不符合全局转换器的规则，那么可以单独指定某个请求的转换器。 httpGet { val param = CustomListParams() httpConfig = config param.addExtraConvert(ApiResponseExtraConvert()) params = param onSuccess> { } } 注：只有在使用默认的解析器的前提下，才可以配置转换器，否则转换器无效，也可以在转换器中根据后台返回的状态码来实现自己的逻辑操作。 事例： class ApiResponseExtraParser : IResponseExtraConvert { override fun convertCommonData(result: String?, response: IHttpResponse) { val json = JsonHelperImpl.parseObject(result) response.state = json.getInteger(\"status\") ?: 0 response.message = json.getString(\"msg\") ?: \"\" response.data = json.getString(\"data\") if (response.state == 600) { ReLoginDelegate.reLogin(\"登录已过期，请重新登录\") } if (response.state != 0) { throw HttpException(code = response.state, msg = response.message) } } } Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-09-11 10:29:10 "},"http/取消.html":{"url":"http/取消.html","title":"取消","keywords":"","body":"1. 取消 框架中每一个异步请求都是可以取消的，无论是在请求已经发起的，还是请求已经在执行的。 很多时候我们不会对单个请求进行取消，而是在页面退出时取消页面发起的所有请求以释放资源，所以框架提供cancelAll()方法取消所有的请求。 Sdk.http().cancelAll() Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-09-11 10:29:10 "},"http/缓存.html":{"url":"http/缓存.html","title":"缓存","keywords":"","body":"1. 缓存 开发的时候，我们可能对数据缓存有需求，框架提供缓存机制，只需要在参数中重写cacheable()方法并返回true即可，事例： @HttpRequest(\"mock/example/four\") class CustomListParams() : DefHttpParams() { val username = \"mljr\" override fun cacheable()=true } 注：缓存模式：发起请求前如果本地已经缓存，会先返回缓存数据，然后在向服务器做请求，如果返回的数据一样，则不做操作，如果不一样则返回给用户，并且更新缓存。 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-09-11 10:29:10 "},"http/下载.html":{"url":"http/下载.html","title":"下载","keywords":"","body":"1. 下载 如果使用网络框架下载文件 首先继承DefHttpParams(url)，要实现IDownloadFeatures的接口 open class ApiDownloadRequestParam(url: String, override var downloadFileSavePath: String) : DefHttpParams(url), IRequestParams.IDownloadFeatures { //关闭断点续传 override fun isAutoResume(): Boolean = false } 在代码中的调用 httpGet{ var param = ApiDownloadRequestParam(url,path) params = param; onSuccess { } //实时进度 onProgress = { curr, total -> } } 1.2. 参数释义 url是指服务器的地址 path是指保存文件的目录拼接上文件名，如http://www.easy-mock.com/files/abc.apk 1.3. 其他特性 框架提供了下载策略来支持此类业务，同时包括断点续传 interface IDownloadFeatures { /**获取进度刷新间隔*/ fun getProgressSpacingTime(): Long = 300L /**文件保存路径*/ var downloadFileSavePath: String /**是否使用断点续传*/ fun isAutoResume(): Boolean = true /**是否根据头信息自动命名文件*/ fun isAutoRename(): Boolean = false } Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-09-11 10:29:10 "},"http/异常和失败.html":{"url":"http/异常和失败.html","title":"异常和失败","keywords":"","body":"1. 异常和失败 Http请求大致分为三个阶段，连接-发送数据-读取数据， 一般容易发生异常的地方也就是这三个地方 1.1. 连接阶段 属于解析参数阶段，容易发生以下错误 Url为null抛出IllegalStateException 网络不可用时抛出HttpException 服务器连接失败时抛出UnknownHostException 服务器连接超时抛出TimeoutException 网络连接错误抛出ConnectException1.2. 发送数据阶段 这个阶段很少发生错误1.3. 读取数据阶段 返回的状态码不在200-299直接会抛HttpException,msg为 一般发生最多的是解析数据的错会抛出HttpException，msg为数据解析错误>，报这个错误的时候就是你提供的解析数据类型和服务器返回的数据不匹配，解析失败造成的，需要重新检查你的解析器和转换器 还有自己定义的model和服务端返回的数据是否匹配。 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-09-11 10:29:10 "},"rainbow/":{"url":"rainbow/","title":"页面管理器-Rainbow","keywords":"","body":"Rainbow Rainbow库是皓月中的页面路由管理库。取彩虹的优雅、连通、无限之意。 Rainbow库的功能开发参考了阿里和美团的路由库设计理念，再结合我们本身的业务特点和开发习惯进行了实现。Rainbow库的页面基于Fragment开发，提供了基于Fragment的页面跳转等路由操作。后续我们会考虑支持Activity的路由管理。 Rainbow库有如下特点： 解耦页面间强依赖 提供基础页面，便于快速开发 支持滑动关闭 支持打开页面在当前做回调处理 支持以注解方式添加页面到路由 支持路由拦截器 支持自定义页面跳转处理 支持页面动画自定义 结合皓月，支持更多功能扩展 1. 快速集成 下述配置都在当前Module的build.gradle中完成。Rainbow使用了编译期注解处理，用来收集页面的注解信息，所以在添加库依赖的同时，需要配置注解处理器，如下： // 第一步：添加Kapt插件，kotlin的官方插件 apply plugin: 'kotlin-kapt' // 第二步：添加依赖 dependencies { // module的其他依赖项 ... // rainbow库依赖 api \"com.meili.moon.sdk:page-router:版本号\" // 注解处理器依赖 annotationProcessor \"com.meili.moon.sdk:page-router-processor:版本号\" kapt \"com.meili.moon.sdk:page-router-processor:版本号\" } 2. 使用方式 Rainbow库的使用主要分三步：初始化、页面开发、页面跳转。 2.1. 初始化 Rainbow类提供了Rainbow库大部分Api的入口，包括初始化方法。 初始化方法只需要调用一次即可，一般在Application的onCreate方法中进行，如下： // 在Application的onCreate中进行Rainbow初始化 Rainbow.init(this) 初始化方法会将收集到的注解信息在Rainbow中进行注册，并做一些运行上下文环境的初始化 修改Application主题，将Application主题设置为继承自RainbowAppTheme主题。在RainbowAppTheme主题中，使用了无ActionBar的浅色模式，主要设置了window的半透明。使用方式如下： // 其他主题的属性设置 如果不设置此主题，可能导致页面背景颜色错误等问题 2.2. 页面开发 继承RainbowFragment Rainbow库要求注册管理的页面是RainbowFragment类型，所以你的业务页面都应该是RainbowFragment的子类，例如声明一个登陆页面： class LoginFragment : RainbowFragment() {} 一般情况下，你应该实现一个继承自RainbowFragment的自定义通用Fragment，例如PageFragment、BaseFragment等等，其他业务页面继承自定义的基类，方便进行页面的统一功能定制与扩展 PageName注解 在完成页面的声明之后，给页面添加PageName注解，指定他的PageName，例如： @PageName(\"login\") class LoginFragment : RainbowFragment() {} 在Rainbow库中，每个页面的PageName必须全局唯一。PageName作为页面Id使用，表示唯一的一个页面，后续的页面跳转也会基于PageName跳转。 PageName注解中的\"login\"就是当前页面的PageName，并且会自动在代码编译期，在PageConfig类中生成LOGIN常量，其值为：login。后续的页面跳转我们推荐使用PageConfig.LOGIN进行页面跳转。更多相关信息，请参考PageName章节 实现onPageCreated() 在继承RainbowFragment时，必须实现其onPageCreated()方法，此方法相当于Activity的onCreate方法，一般在其中做一些页面初始化逻辑等内容，如下： @PageName(\"login\") class LoginFragment : RainbowFragment() { /** * 当页面已经创建 回调方法 */ override fun onPageCreated(view: View, savedInstanceState: Bundle?) { // 处理业务逻辑 } } 指定布局 我们可以通过Layout注解，指定当前页面布局；也可以通过重写getLayoutResId()方法指定页面布局，如下： @PageName(\"login\") @Layout(R.layout.login_fragment) class LoginFragment : RainbowFragment() {} 至此，我们就完成了一个页面的基本设置，并可以在其上开发业务逻辑了。 2.3. 页面跳转 我们继续使用上面Login的例子。在上面注解章节中我们已经添加了PageName注解，框架将根据注解自动在PageConfig类中生成LOGIN常量，用做跳转LoginFragment的PageName入参。下面的例子中我们会使用此常量进行跳转。 不带参数的跳转 如下：// 跳转到login页面 gotoPage(PageConfig.LOGIN) 带参数的页面跳转 我们提供了两种页面跳转的入参方式，你可以根据使用习惯任意使用 方式一：Bundle方式入参// 页面入参 val args = Bundle() args.putString(\"userId\", \"xxxxxx\") gotoPage(PageConfig.LOGIN, args) 方式二：扩展方式入参// 页面入参 gotoPage(PageConfig.LOGIN) { putExtra(\"userId\", \"xxxxxxx\") } forResult的页面跳转 在“A页面 -> B页面，当B页面完成业务逻辑后，A页面处理B页面的结果信息“这个案例中，B页面通过setResult(result)方法设置结果内容。在A页面中我们提供两种接收结果的方式 方式一：多用在不需要页面入参，或者页面入参是已经现有的Bundle对象时。 fun openLogin(args: Bundle) { // 打开login页面 gotoPage(PageConfig.LOGIN, args) { result -> } } 在上面的例子中，我们新增了方法泛型和接收结果回调的lambda。此泛型是由目标页面的setResult()方法入参类型决定的，同时lambda中result的类型也由泛型推导得出，如图： 方式二：推荐的使用方式，在lambda中扩展入参和回调 mBtnGotoLogin.onClick { // 打开login页面 gotoPage(PageConfig.LOGIN) { // 设置入参 putExtra(\"from\", \"test\") //获取回调 onResult { result -> // 回调结果 } } } 在上面的例子中，onResult()方法的泛型和lambda中的入参都和目标页面的setResult()参数类型一致，可以参考方式一的图，不再赘述。 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-09-11 10:54:23 "},"rainbow/注解使用.html":{"url":"rainbow/注解使用.html","title":"注解使用","keywords":"","body":"注解使用 Rainbow库中提供了两种页面注册相关的注解，分别是：PageConfigParams、PageName。 1. PageConfigParams注解 在代码编译期，我们会使用apt技术收集代码中的PageName注解信息。再使用poet库动态生成PageConfig类，将收集到的注解信息写入PageConfig中。在多子Module开发时，最终子Module编译内容需要合入主工程，这会造重名类被覆盖，也就是PageConfig类被覆盖的问题。为了解决这个问题，我们提供了PageConfigParams注解，我们在编译期，先收集PageConfigParams注解信息，再根据其参数动态生成PageConfig类名，以避免重名覆盖的问题。PageConfigParams注解现在只支持设置PageConfig的前缀参数，定义如下： /** * 设置生成的的pageConfig的名称前缀 * 在library项目中必须设置，并且前缀必须唯一，重名的话在多module情况下，会有PageConfig覆盖的情况 * 一般使用当前项目名称，例如：设置为Login，则最后生成为LoginPageConfig。注意首字母大写 * 在Application项目中可以不设置，默认使用PageConfig */ String pageConfigPrefixName() default \"\"; 此注解只需要设置一次即可，一般设置在Application上，或者设置在app的入口页面上。 2. PageName注解 PageName注解用来收集页面的配置信息，支持PageName、注释、分组、拦截器的配置，配置方式如下： // 设置PageName、备注信息、分组信息、拦截器信息。 @PageName(\"pageName\", note = \"备注信息，可选\", affinity = \"分组信息，可选\", interceptors = [UserCheckInterceptor::class]) class LoginFragment : RainbowFragment() {} 此配置信息将被收集到PageConfig类中。如果配置了PageConfigParams注解，将以注解中配置的名称为前缀的PageConfig中。生成的常量命名方式为：将pageName中的‘/’替换为'_'，然后全部变为大写，例如： login -> LOGIN login/logout -> LOGIN_LOGOUT homeContainer -> HOMECONTAINER home/container -> HOME_CONTAINER 备注信息将作为生成的常量的代码注释，便于理解常量含义，可选。 affinity是延续使用的Android命名风格，作为可选分组。 interceptors是页面拦截器，页面特殊指定，可指定多个。更多拦截器内容请阅读拦截器章节 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-09-04 14:23:48 "},"rainbow/页面导航.html":{"url":"rainbow/页面导航.html","title":"页面导航","keywords":"","body":"页面导航 页面A -> 页面B，页面B再返回到页面A都需要导航api的支持。Rainbow中的导航功能主要有：原生导航实现、便捷的导航扩展、页面结束 1. 导航功能 PageManager接口定义了导航功能，可通过Rainbow.page()获取其实例。 PageManager中定义了两类导航功能，分别是：Fragment导航和Activity导航；前者用来管理Rainbow中的页面导航，后者提供Rainbow开启Activity功能。 PageManager中提供的导航方式，在任意位置都可使用，例如打开一个Login页面： val pageIntent = PageIntent(PageConfig.LOGIN) Rainbow.page().gotoPage(pageIntent) { //结果回调，可选 } 在我们平时开发中，很少用到 A页面 -> A页面 这种情况。出现这种情况往往是因为用户误操作，连续点击了两次按钮，导致打开了两个相同页面。针对这种情况，Rainbow中默认新页面不能和栈顶页面相同，否则将不能打开。在判断是否为相同页面时，我们采用的是PageName+NickName的方式，如果两个值都相同，则认为是同一个打开操作，所以在打开页面时，可以使用不同的nickName入参来区分不同页面。当然，我们也提供了打开入参来控制策略，可通过gotoPage()的方法入参canSameWithPre进行控制，也可以通过设置全局Config更改默认策略，如下： // 使用nickName的方式区分 val pageIntent = PageIntent(PageConfig.LOGIN) pageIntent.nickName = PageConfig.LOGIN + userId Rainbow.page().gotoPage(pageIntent) { //结果回调，可选 } // 使用方法入参的方式控制 val pageIntent = PageIntent(PageConfig.LOGIN) Rainbow.page().gotoPage(pageIntent, canSameWithPre = true) { //结果回调，可选 } 在任意位置打开Activity，如下： val intent = Intent() intent.setClass(context, clazz.java) Rainbow.page().gotoActivity(intent) { //结果回调，可选 } Android设计的forResult通过requestCode和resultCode做请求区分和结果区分，其中resultCode通常使用系统预定义的RESULT_OK、RESULT_CANCEL。其中RESULT_CANCEL是用户没有设置结果的状态，这种状态下，一般我们在回调中不处理；为了简化回调中的判断，我们对回调做了过滤；默认只有resultCode = RESULT_OK时，lambda中才能得到回调。但是为了满足特殊情况，你可以通过入参intent进行设置，接收RESULT_CANCEL回调，通过结果intent获取resultCode，例如： val intent = Intent() intent.setClass(context, clazz.java) // 设置接收cancel intent.receiveCancelResult = true Rainbow.page().gotoActivity(intent) { result -> // 可以接收cancel的回调 // 根据intent上的resultCode，处理不同业务逻辑 if(result.resultCode == RESULT_OK) { // 处理成功逻辑 } } 这里的Rainbow.page().gotoActivity()只有在当前栈顶是Rainbow页面时，才能正常接收页面结果回调。关于结果回调的更多信息，可以参考下面的章节。 2. 导航扩展 在上面所述的导航方式中，调用略显麻烦，所以我们对RainbowFragment和Context添加了一些导航扩展方法，用来简化常用导航。在页面跳转章节中我们已经介绍过了扩展导航的使用方式。这里详细看一下方法入参，以及含义，如下： /** * 跳转到指定页面 * * 使用举例： * val arguments = Bundle() * arguments.putIntExtra(\"id\", id) * gotoPage(\"order/detail\", bundle) * * [pageName] 跳转的页面名称，可以通过PageDefine的方式或者注解的方式进行添加和查询 * * [bundle] 给下个页面的参数 */ fun gotoPage(pageName: String, bundle: Bundle? = null, nickName: String? = null) 在PageIntent中，可以设置打开页面的nickName，nickName是作为区分两个相同PageName页面而存在的，当前Rainbow库默认策略是不能在栈顶同时打开两个相同页面；此策略是为了防止用户误操作引起打开重复页面。但是在有些时候需要连续打开两个相同页面，这时就需要为每个打开操作设置不同的nickName；nickName可以是任意值，例如当前时间、当前页面关键信息的id等。 除了上述方法外，还有其他几个类似的打开方法，不再赘述，详细api可以参考SdkFragmentExtra_.kt。 3. 页面关闭 页面关闭功能以及页面打开功能的api都在PageManager中定义，可以通过Rainbow.page()获取PageManager实例。功能定义如下： /**结束所有页面*/ fun finishAll() /** * 从当前顶部fragment开始，结束指定步数的页面 */ fun finish(step: Int, page: Page) 你可以通过finishAll()方法结束所有Rainbow页面，也可以通过finish()方法结束指定步数的页面，例如： // 结束两步 Rainbow.page().finish(2, this) Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-09-24 16:49:47 "},"rainbow/RainbowFragment定制.html":{"url":"rainbow/RainbowFragment定制.html","title":"RainbowFragment介绍","keywords":"","body":"RainbowFragment RainbowFragment作为路由库的基础页面使用，当前路由管理的所有页面都是基于RainbowFragment开发。 RainbowFragment主要提供的功能有：声明周期相关、交互相关。 1. 生命周期 RainbowFragment是Fragment的子类，他自身有Fragment相关生命周期。但是Fragment生命周期在堆栈管理中，回调不稳定，容易出现错误，同时也为了给框架留有更多的扩展空间。所以Rainbow中禁用了大部分系统生命周期，并提供了相对稳定的生命周期，这些生命周期都定义在PageLifecycle中，主要方法如下： /** * 当页面已经创建 回调方法 * 一般用作初始化页面控件、逻辑、数据等操作 */ fun onPageCreated(view: View, savedInstanceState: Bundle?) /** * 当页面由后台跑到前台 回调方法 * 一般用于实现依赖页面展示时机的操作 */ fun onPageResume() /** * 当页面正在销毁，在[onPageDestroyView]后,[onPageDetach]前 回调方法 * 一般用作回收页面对象、属性等内容 */ fun onPageDestroy() 除了上述常用的三个声明周期方法，还有其他更多方法，可参考PageLifecycle接口定义。 在RainbowFragment中onPageCreated()方法是必须实现的方法，用于进行页面的主要初始化逻辑，例如设置点击事件、请求服务器接口、初始化控件内容等等，相当于Activity的onCreate()方法。 1.1. RainbowFragment中状态判断 在处理页面事件时，我们需要关注页面当前状态是否可做交互操作，以避免一些意外情况发生。例如，当页面正在loading，用户点击了页面标题栏的菜单按键，此时页面还不可以交互，否则可能出错。在RainbowFragment中，我们定义了Interactive接口，用来说明当前对象是否可以交互，具体定义如下： /** * 当前可交互的标准接口 */ interface Interactive { /**是否可交互 true：可交互 false：不可交互*/ var interactive: Boolean } 一些基类，或者通用方法，可以通过判断对象的interactive值来判断当前对象是否可交互，从而有检验标准的同时，不用强依赖RainbowFragment。 同样，在处理异步回调时，我们也标准化了当前页面是否已被销毁的接口，如下： /** * 当前对象是否已经被销毁，可销毁对象的标准化接口 */ interface IDestroable { /** * 当前对象是否已经被销毁，true 已销毁，false 未销毁 */ var hasDestroyed: Boolean } RainbowFragment实现了此接口，减轻了一些扩展方法对RainbowFragment类的依赖，可通过IDestroable对象进行销毁判断。 在RainbowFragment中，提供了一些类似Activity的状态判断方法，例如：isFinishing()页面是否正在结束、isPaused()页面是否已经处于paused状态、isFront()页面是否在栈顶等 2. 相关交互 RainbowFragment提供了一个页面最常用的一些交互，主要有：Titlebar、PageStatesView、PageNotification。 2.1. Titlebar RainbowFragment默认集成了Titlebar。Titlebar提供了返回按钮、页面名称、页面菜单三个常用主要功能，效果如下： Titlebar的功能可以通过Rainbow中的api直接控制，如关闭默认Titlebar： /** * 重写是否使用默认Titlebar，禁用默认Titlebar。默认情况使用Titlebar */ override fun isUseDefaultTitleBar() = false 将默认Titlebar设置为自定义的Titlebar： /** * 当页面已经创建 回调方法 */ fun onPageCreated(view: View, savedInstanceState: Bundle?) { // mTitleBar是RainbowFragment中声明的成员变量，Rainbow中的Titlebar相关接口都针对此对象操作 mTitleBar = specialTitlebar } mTitleBar是RainbowFragment中声明的成员变量，Rainbow中的Titlebar相关接口都针对此对象操作。 设置页面名称，如下： /** * 当页面已经创建 回调方法 */ fun onPageCreated(view: View, savedInstanceState: Bundle?) { setTitle(\"个人中心\") } 添加文字菜单： /** * 当页面已经创建 回调方法 */ fun onPageCreated(view: View, savedInstanceState: Bundle?) { addMenuText(\"MenuText\") { // Menu的点击事件 } } 添加Icon菜单： /** * 当页面已经创建 回调方法 */ fun onPageCreated(view: View, savedInstanceState: Bundle?) { addMenuIcon(R.drawable.menu_icon) { // Menu的点击事件 } } 更多菜单设置，可参考ITitleBarView接口定义。ITitleBarView接口定义了Titlebar的主要常用功能，RainbowFragment默认使用的Titlebar就是其子类：RainbowTitleBarView。它可以使用通过主题进行样式自定义，具体支持的内容如下： 这些style可以通过主题进行通用配置。在主题中RainbowTitleBarView接收rainbowTitleBarView属性，rainbowTitleBarView属性值指向你的自定义style，例如： @style/SelfRainbowTitleBarView #ff0000 5dp @drawable/ic_launcher ...更多其他属性 在某些情况，你需要单独设置Titlebar的样式，例如透明主题，可以通过Titlebar的setStyle()方法进行自定义，此方法也接收RainbowTitleBarView中定义的属性设置。 2.2. PageStatesView 页面在使用过程中，通常包含多种状态，例如：加载中、加载失败、加载内容为空、加载成功等等。在RainbowFragment中，归纳了这些常用状态，并实现了PageStatesView控件，用来承载这些状态。RainbowFragment默认内置PageStatesView。PageStatesView的默认状态为隐藏，你可以根据业务需要调用相应api进行状态切换。 2.2.1. 常用api 在RainbowFragment包含一个mStateView成员变量，用来管理PageStatesView。可以通过重写isUseDefaultPageStatesView()方法，来定制是否加载默认PageStatesView，如下： /**是否使用默认的pageStatesView，如果要自己实现，可返回false*/ override fun isUseDefaultPageStatesView() = true 显示loading状态view，如下： mStateView.showLoading() 显示错误状态view，如下： mStateView.showError() 显示空内容状态view，如下： mStateView.showEmpty() 隐藏PageStatesView，如下： mStateView.gone() 监听特定状态下的状态View点击，如下： // 设置错误状态View的点击事件回调 mStateView.setOnStateClickListener(PageStatesView.STATE_ERROR) { } 由于错误、空这两种状态是经常需要鉴定点击事件，从而做刷新等操作的状态，所以我们提供了两个便捷方法，如下： // 设置错误状态View的点击事件回调 mStateView.setOnErrorClickListener { } // 设置空状态View的点击事件回调 mStateView.setOnEmptyClickListener { } 2.2.2. 自定义PageStatesView中的状态View 在我们开发时，有可能需要自定义状态对应的View，在PageStatesView中，提供了几种常用Int类型的状态，分别对应一个PageStateItemView类型的View，再通过不同的show方法展示指定状态对应的View。PageStateItemView是各个子状态View的真正实例载体。PageStateItemView类中提供了一个AbsStateItemView类，用来简化StateItemView的实现。下面，我们使用AbsStateItemView来自定义实现一个Error状态View。 第一步：继承AbsStateItemView来实现自己的View，并实现其中的抽象方法 open class PageStateErrorView(parent: ViewGroup) : PageStateItemView.AbsStateItemView(parent) { /**页面的layout资源id*/ override fun getLayoutId(): Int = 当前View需要加载的layoutId // 当前页面对应的状态 override val state: Int = PageStatesView.STATE_ERROR // 当前页面的Params override var stateParams: PageStateParams = Params() override fun notifyParamChange() { super.notifyParamChange() // 使用stateParams中的参数，对当前view进行显示设置。 } // 自定义的当前页面param类 class Params : PageStateEmptyView.Params() { /**提示的文案*/ override var tipText: CharSequence = \"出错了😭\" } } 如上述代码所示，在一个State中，会对应实现一个Params，用来接收和初始化默认参数。 在错误状态时，我们通常关心错误页面的点击事件，用以提供给外部进行页面刷新等操作，所以我们需要重写getOnClickView()方法，用来提供点击事件的View，如下： // 提供错误页面的button作为点击View override fun getOnClickView(): View = mTxtPageStateErrorReload 第二步：在PageStatesView中添加自定义StateItemView到指定状态，如下：mStateView.addStateView(PageStateErrorView(mStateView)) 第三步：使用自定义PageStateItemView。如果你的自定义View使用的是预置状态，那么可以直接使用原有show方法即可展示切换，如果是新增状态，需要使用show(state)方法进行展示，如下：// 我们自定义的状态View是使用的预置STATE_ERROR mStateView.showError() 2.3. 页面内Notification 页面内Notification的作用和Toast相似，从页面的titlebar下弹出，可以设置文案等内容，效果如下： 2.3.1. 使用方式 Rainbow提供了三种状态的PageNotification，分别是：默认、成功、失败。在RainbowFragment中对应的使用方式如下： // 默认的页面通知 showNotification(\"页面内通知示例：默认\") // 表示失败的页面通知 showNotificationFailed(\"页面内通知示例：错误、失败\") // 表示成功的页面通知 showNotificationSuccess(\"页面内通知示例：成功、通过\") 下面，我们简单看一下showNotification()方法的定义，以及扩展使用，如下： /** * 显示一个notification，默认2秒关闭 * * 如果设置 关闭时间 根据如上api我们可知，我们可以自定义通知展示时间和通知的点击事件。如果我们设置的展示时间小于等于0，则页面通知就成了常驻形式。在常驻形式下，如果设置了他的点击事件，则会自动展示通知末尾的箭头图标，用来引导用户点击。 2.3.2. 自定义样式 Rainbow支持在主题中定义页面通知样式，具体的定义方式如下： @style/selfNotificationNormal @style/selfNotificationFailed @style/selfNotificationSuccess 在主题中属性引用的Style中，具体可自定义属性如下： Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-09-24 15:40:03 "},"rainbow/最佳实践.html":{"url":"rainbow/最佳实践.html","title":"最佳实践","keywords":"","body":"最佳实践 Rainbow库作为页面管理的基础库，为了简化开发的接入成本，本身会提供很多常用功能与设置。下面我们从配置方式、常用api、层级结构三方面来分别介绍一下Rainbow库中的最佳实践。 1. 通用配置 在Rainbow类中，我们提供了config()方法用来对Rainbow库做全局配置。一般在Application中进行一次配置即可，例如： class MyApplication : Application() { override fun onCreate() { // 对Rainbow进行全局设置 Rainbow.getConfig().apply { // 设置app特定的schema，一般用来支持外部链接打开app appSchema = \"moon\" // 是否可打开相同页面，默认为true canOpenSamePage = true } } } 具体可以支持的配置属性可参见：com.meili.moon.sdk.page.RainbowConfig类。 1.1. 支持H5地址跳转 在Rainbow中，我们支持gotoPage()方法直接打开一个H5地址，如下： // 直接打开url地址 gotoPage(\"https://moon.mljr.com/\") 为了支持此种打开方式，我们必须在RainbowConfig中进行配置：h5PageName、h5OpenProcessor。这两个参数用来设置当打开的页面是http url时，使用何种方式打开，通常只需要配置一个即可。我们推荐的两种实现方式为：自定义通用H5Fragment管理app所有h5页面打开、跳转指定fragment或者交给系统进行处理。 1.1. 自定义通用H5Fragment 这种方式是我们推荐的使用方式，通过定义基于RainbowFragment的通用H5Fragment进行H5打开管理。通常其中包含一个Webview，并且有对应的管理方案。H5Fragment的注册方式同普通页面一样，不同的是需要在RainbowConfig中初始化h5PageName属性，如下： class MyApplication : Application() { override fun onCreate() { // 对Rainbow进行全局设置 Rainbow.getConfig().apply { h5PageName = \"注册的H5Fragment的PageName\" } } } 注册完成以后，在自定义的H5Fragment中需要关注url参数，此参数是打开url的通用入参命名，获取方式如下： @PageName(\"common/h5\") class H5Fragment : RainbowFragment() { /** * 当页面已经创建 回调方法 */ fun onPageCreated(view: View, savedInstanceState: Bundle?) { // 打开url时，下个页面接收到的bundle中，会有名称为url的网页地址 // 结合上面的例子，这里的值为：https://moon.mljr.com/ val url = arguments?.getString(\"url\") } } 至此，我们的app就支持了直接打开h5链接 1.2. 自定义打开过程 在上文中，我们介绍了使用全局通用H5Fragment进行H5打开管理，一般情况下已经够用。但是在特殊情况下，例如app自己不做h5打开管理，直接交付给系统处理，或者有其他的使用情况，需要根据不同的条件，跳转不同的打开操作。这时候，可以通过配置RainbowConfig中的h5OpenProcessor参数来管理打开过程。h5OpenProcessor的处理优先级高于h5PageName参数的优先级，具体配置方式如下： // 对Rainbow进行全局设置 Rainbow.getConfig().apply { // 配置H5的打开操作处理对象 h5OpenProcessor = processor@{ uri, intent, canSameWithPre, destroyable, pageCallback -> // uri的类型为Uri类型，intent类型为PageIntent return@processor true } } 在h5OpenProcessor的回调中，你可以通过uri和intent参数，自行判断是否需要进行打开处理，如果不进行处理返回false，否则返回true。如果没有设置h5OpenProcessor，或者h5OpenProcessor返回false，则会降级使用h5PageName配置进行打开。如果h5PageName和h5OpenProcessor参数都没有设置，则会报错。 2. 常用Api 在Rainbow库中，我们提供了一些封装的常用api，用来简化调用。 2.1. onClick方法 我们对View提供了onClick()扩展方法，在支持点击事件的通知，扩展了两个特性：支持防止按钮重复点击、支持onClick时错误捕获，使用方式如下： // 添加点击事件 mBtnTest.onClick { gotoPage(\"otherGroup\") } 2.2. 全局post 在平时开发中，经常用到Handler的post方法，我们提供了全局post，用来简化post调用，如下： // 执行post post { // 业务处理 } // 执行延时post post(500) { // 业务处理 } 在使用全局post的时候，需要注意内存泄漏问题，不应该使用过长时间的延时post，否则可能导致页面的内存泄漏。 2.3. 全局Application 我们扩展了全局的Application对象：app，用来简化一些上下文参数，如下： // 使用全局app获取resource val resource = app.getResource() 2.4. 全局Debug判断 我们扩展了全局的isDebug对象，用来简化获取当前运行环境是否为debug，如下： if(isDebug) { // debug下的逻辑 } 3. 层级结构 在之前章节中介绍过，基于Rainbow库开发时，页面必须使用RainbowFragment作为基类。在开发app时，我们应该自定义一个继承自RainbowFragment的Fragment作为app的基类，方便对基础页面进行扩展，例如定义为PageFragment，我们可以在其中定义更多的页面常用设置，以提高开发效率。 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-09-25 11:36:14 "},"event/":{"url":"event/","title":"事件分发-Event","keywords":"","body":"Event 皓月有自己的一个轻量级事件订阅库，主要用在页面间事件订阅，他就是我们这里要讨论的Event库。Event库主要功能是将事件分发给匹配事件的订阅者，如图： 1. 快速集成 Event库由于实现很轻量，所以抽象和实现都在kit库中，引入kit库就集成了Event功能。具体kit库的引入方式请参见：kit引入文档 2. 使用方式 Event的使用分两部分：订阅事件和发送事件。所有功能都由CommonSdk.event()提供。 2.1. 订阅事件 第一步：将需要接收事件的实例在Event库上进行注册 CommonSdk.event().register(this) 一般此方法放到基类的onCreate中，用来作为当前类的统一注册方式。和此类对应的方法为注销方法，当类退出时进行调用释放资源，如：CommonSdk.event().unregister(this) 第二步：添加事件订阅方法 Event库支持以注解的方式添加事件订阅。订阅事件类型由注解方法的入参类型决定。例如： @Event private fun onUserUpdate(event: UserUpdateEvent) { //处理事件 } 如上示例，订阅方法的入参必须有且仅有一个参数，此参数即为你要订阅的事件类型。订阅方法只会接收到入参类型的事件分发。 订阅类型不支持类型间的继承关系，只能匹配当前订阅类型的消息，而不能父类型接收子类型消息。 2.2. 发送事件 在你生成事件的位置，进行发送，支持发送任意类型的事件： CommonSdk.event().post(userUpdateEvent) 至此，你就可以订阅并发送事件了 3. 高级特性 我们的Event消息分发都是在主线程进行的，属于同步发送。如果是在子线程进行消息发送，也会默认将消息转到主线程后再分发。 Event库除了提供上述通用功能外，还提供了三种高级特性： 从事件接收顺序角度来讲，Event库支持订阅者自定义优先级，优先级越高，处理事件的时机越靠前。 从事件受众角度来讲，Event库支持单点接收、接收者阻断事件、全员接收。 从Android的使用习惯角度来讲，Event库为Bundle类型事件提供了特殊功能定制。 3.1. 事件优先级 我们所有的订阅者对事件的接收都会有默认排序，排序规则是：事件接收顺序是注册的反序，即最后注册的订阅者，最先得到事件，如图： 因为我们的Event库大部分时候是用在页面间进行信息通知，所以我们认为越靠近堆栈的顶部页面，就越急需处理事件消息。一般情况下，越接近栈顶，就越晚注册，所以我们的默认排序如上。 在订阅事件时，有时我们需要设置某个订阅者对事件的处理优先级最高，以便优先处理某个业务，这时候就需要对所有订阅者做自定义排序。我们在Event注解中提供了priority字段用于优先级设置，此字段为Int类型，默认为0，值越大优先级越高，如： @Event(priority = 10) private fun onUserUpdate(event: UserUpdateEvent) { //处理事件 } 3.2. 事件的发送 在发送事件时，有时我们为了满足各种业务需求，需要对事件的发送做一些特殊设置。我们为发送者提供了三种功能： 发送者决定只能有一个接收者接收消息 发送者决定消息可以被中间接收者拦截 发送者决定消息应该被分发给每个接收者 为了满足以上消息的传送规则，我们为Event的post方法提供了第二个参数：TransferEnum。从命名上不难看出他是枚举类型，TransferEnum提供了三种枚举，如下： enum class TransferEnum { /**只有第一个订阅者会接收到消息*/ ONLY_FIRST, /**根据订阅者方法返回值确定是否继续传递，如果没有返回值或者返回值为false，则继续发送下一个订阅者，否则终止发送*/ BY_SUBSCRIBER, /** 所有的都可以接收到*/ ALL } Event库的默认发送方式为TransferEnum.ONLY_FIRST，你也可以使用TransferEnum，进行自定义消息发送方式，例如： // 指定消息发送方式为：BY_SUBSCRIBER CommonSdk.event().post(event, TransferEnum.BY_SUBSCRIBER) 在发送消息时，大部分情况下我们不希望当前实例再接收到此消息，例如我们要发送消息A，同时当前实例也订阅了消息A，但是我们在当前实例不希望接收自己的消息，我们可以通过在发送消息时，添加忽略对象进行设置，例如： // 指定消息发送方式为：BY_SUBSCRIBER，并且忽略当前实例接收此消息 CommonSdk.event().post(event, TransferEnum.BY_SUBSCRIBER, this) 或者 // 忽略当前实例接收此消息 CommonSdk.event().post(event, ignored = this) 当发送消息的传输类型设置为TransferEnum.BY_SUBSCRIBER时，如果你想订阅并且拦截此消息，你可以通过订阅方法的返回值进行拦截：true拦截消息，false或返回void表示不拦截。如果你拦截了消息，那么小于此订阅者优先级的订阅者，将不再得到消息通知。例如： @Event(priority = 100) private fun onUserUpdate(event: UserUpdateEvent) : Boolean { //处理事件 if(特殊情况) { // 拦截当前事件 return true } // 不拦截当前事件 return false } 其他传输类型，暂时不支持某个订阅者拦截。 3.3. Bundle类型优化 在消息订阅模型中，每种业务都应该有一种自己的消息类型。在Java或者Kotlin中的表现就是，每种业务消息，都应该映射出对应的消息类定义，例如：UserUpgradeEvent、UserLoginEvent、UserLogoutEvent等等。而不应该使用某种通用类型作为消息类型和订阅类型，例如：List、Map、Int、String、Boolean、Long、Date等等。因为这些通用类型不能代表和说明某种业务场景，也就不能表示某种业务消息。 我们提供了IEvent接口，用做消息类型的标准。推荐继承此接口，实现具体的业务消息。在后续开发中，可能会强制要求发送消息必须为IEvent类型，订阅消息的入参也必须是IEvent类型，否则将在开发期报错。 在Android开发中，Bundle类型是系统提供的官方传输类型，是比较通用的一种数据类型。考虑到Bundle类型的通用性和广大同学的习惯，我们提供了专门为Bundle类型的优化，Bundle类型也基本上是可使用的通用类型的底线。 我们借鉴了系统页面间消息的传递方式，系统通过requestCode区分当前页面不同业务的返回结果。我们在Event注解上提供了value属性，用于仿照requestCode的作用。如果你当前订阅的事件类型为Bundle类型，那么你需要提供value属性，作为你监听Bundle类型的消息类型ID，也就是说，只有符合此ID的Bundle消息，才会在此方法中得到通知，例如： @Event(value = UserConstants.UPDATE_EVENT) private fun onUserUpdate(event: Bundle) { //处理事件 } 在你发送Bundle类型消息时，必须提供Key值为BUNDLE_KEY的Int内容，用来匹配消息类型Id。BUNDLE_KEY定义在Events.kt中。发送消息的方式如： // 在bundle中添加目标ID eventBundle.putInt(BUNDLE_KEY, UserConstants.UPDATE_EVENT) CommonSdk.event().post(eventBundle, ignored = this) Bundle类型消息，请慎用。推荐定义value时，使用统一的静态变量进行声明，一来方便命名注释，二来方便统一管理，三来方便使用查找。 3.4. 拦截事件 在特殊情况下，需要对事件进行拦截和过滤，你可以通过注册拦截器，对所有的事件进行拦截处理，如： // 添加拦截器，lambda的第一个参数为消息体，第二个参数为当前处理的订阅对象， // 所以同一个消息，针对不同的接收者，会收到多次回调。 CommonSdk.event().addEventInterceptor { event, subscriber -> // 处理业务逻辑，如果要拦截就返回true，否则返回false return@addEventInterceptor true } Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-10-24 14:09:40 "},"permission/":{"url":"permission/","title":"动态权限-Permission","keywords":"","body":"MoonPermission MoonPermission是一套旨在简化、标准化Android动态权限的动态权限库。在Android6.0以后，对系统权限大体分为两类：正常、危险。正常权限只需要在Manifest文件中进行声明即可，系统会在应用安装时，默认授权。危险权限是有可能涉及用户隐私，危害系统安全的权限，需要在Manifest中进行声明，并且在使用处，明确申请所需权限。 在MoonPermission中，我们简化了动态权限的申请操作，并提供了部分交互，使整体流程更清晰，更人性化，具体特点如下： 支持注解方式，对方法添加所需权限 支持直接调用方式，可自由选择结果回调方式 支持拒绝权限时的用户交互，以及交互定制 1. 快速集成 1.1. Gradle api \"com.meili.moon.sdk:permission:x.x.x\" 具体版本详见：版本更新日志 1.2. 初始化 可以在Application的onCreate中进行初始化：MoonPermissionImpl.init(application) 2. 使用方式 MoonPermission提供两种使用方式：直接调用、方法上的注解。在一次权限请求过程中，有三种请求结果：请求成功、权限被拒、权限被拒并且不再提醒。针对后两种情况，在MoonPermission中，提供了两个弹窗，用来引导用户授权，流程如图： 你可以通过后续的Config选项来定制你的交互细节。 2.1. 直接调用方式 在我们的请求中，可以通过CommonSdk.permission()直接进行MoonPermission上的api调用。例如我们在打开摄像头前，需要请求摄像头权限，如下： mCameraBtn.onClick { CommonSdk.permission().request(Manifest.permission.CAMERA) { // 成功后的回调 // openCamera() } } 如上所示，这种调用方式只有当所需权限都被授权时，回调方法才会触发。如果没有被授权，其中被拒交互将使用默认交互。如果你需要关注被拒的权限列表和被拒时机，你可以调用requestWithFailed()方法，如： CommonSdk.permission().requestWithFailed(Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.CAMERA) { isAllGranted, granted, denied -> // isAllGranted 是否所有权限都被授予 // granted 已经授权的权限列表 // denied 已经拒绝的权限列表 } 以上提供的两个方法的入参，都是可变长参数，根据需要的权限数进行入参 2.2. 注解方式 在MoonPermission中，我们支持对方法添加注解，并在注解上说明此方法所需权限，当其他方法调用此方法时，会先触发授权，在授权成功后再调用此方法。这种处理方式是基于编译期的字节码插桩，修改被注解的方法实现的，所以需要添加如下配置： 在项目根目录的build.gradle中添加classPath // 在buildscript节点的repositories中添加meili库，并在buildscript节点添加classPath buildscript { repositories { // 其他库信息 maven { url MEILI_MAVEN } } dependencies { classpath 'com.meili.moon.gradle:moon-tools:x.x.x' } } 具体moon-tools版本号详见：moon-tools版本更新日志 在使用权限的Module中的build.gradle添加插件 apply plugin: 'moon-kit' 至此插件相关配置已经完成。 在需要权限的方法上，添加Permission注解，还是以camera为例： @Permission(Manifest.permission.CAMERA) private fun openCamera() { // 正常的打开操作 } 关于Permission支持的更多功能，可以参照Permission文档 注意，使用注解的方法，返回类型必须为void，否则将报错 3. 请求配置 在MoonPermission中，我们提供了Config用来进行全局配置和单次请求配置，例如在初始化后，可以进行如下配置： // 初始化 MoonPermissionImpl.init(this) // 全局配置 MoonPermission.Config.newInstance().apply { // 是否使用被拒后的dialog交互，默认为true isDeniedUEAvailable = false // 是否使用被拒并且不再提示后的dialog交互，默认为true isDeniedRememberUEAvailable = false // 是否直接使用 'deniedRemember权限交互'，舍弃使用 'denied权限交互'。 // 如果你不希望用户拒绝后，再弹出授权界面，可设置此项为true。 // 此项为true时，当用户拒绝权限，不管是否被记住，都只会弹出去设置弹窗 isDirectDeniedRememberUE = true // 设置被拒后的弹窗上的title onDeniedTitle = \"权限申请\" // 设置被拒后的弹窗上的描述信息，此String以拼串的方式使用，接收两个string： // 第一个为被拒权限名称列表例如：定位、电话， // 第二个为被拒权限影响的功能名称，例如：地图、打电话。 onDeniedDescription = \"请开启%s权限，以正常使用%s功能\" // 设置被拒并且不再提示后的弹窗上的描述信息，此String以拼串的方式使用，接收三个string： // 第一个为app名称占位符 // 第二个为被拒权限名称列表例如：定位、电话， // 第三个为被拒权限影响的功能名称，例如：地图、打电话。 onDeniedRememberDescription = \"在设置-应用-%s-权限中开启%s权限，以正常使用%s功能\" // 当被拒时，不使用框架默认的交互方式，自定义交互方式 // denied 被拒绝的权限列表 // permissionDesc 被拒绝的权限列表的描述信息 // onCancel 当取消下一步操作时，回调此方法，一般在弹窗的取消按钮上调用 // onSubmit 当继续下一步操作时，回调此方法，一般在弹窗的确定按钮上调用 onDeniedUECallback = {denied, permissionDesc, onCancel, onSubmit -> } // 当被拒并且不再提示时，不使用框架默认的交互方式，自定义交互方式 // denied 被拒绝的权限列表 // permissionDesc 被拒绝的权限列表的描述信息 // onCancel 当取消下一步操作时，回调此方法，一般在弹窗的取消按钮上调用 // onSubmit 当继续下一步操作时，回调此方法，一般在弹窗的确定按钮上调用 onDeniedRememberUECallback = {denied, permissionDesc, onCancel, onSubmit -> } }.commit() 在提示用户某些权限被拒绝，影响某些功能时，我们需要将Android中的系统权限转换为语义文本，我们提供一套默认的string-array资源，用来进行控制，定义在权限库的string中，他的格式如下： 通讯录 名片 android.permission.GET_ACCOUNTS android.permission.READ_CONTACTS android.permission.WRITE_CONTACTS 此数组中，第一个item为转换的权限名称，第二个为影响的功能名称，后续为此名称下的具体权限。当在此组中的权限被拒绝时，将进行类似提示：\"请开启通讯录权限，以正常使用名片功能\"。此提示格式可以通过Config中的onDeniedDescription进行设置。 在框架中，由于对于某些权限并不清楚在app中影响的功能，所以我们暂时使用中划线‘-’进行标记，表示此权限组影响的功能不明确，在提示时将把影响的功能说明隐藏，例如：\"请开启通讯录权限，以正常使用App功能\"。 你也可以自己定义自己的xml进行资源扩展，按照如上格式定义完成后，可使用Config上的registerPermissionGroups()方法进行注册。当然你也可以覆写已经定义的资源id进行定义。 具体的资源id和更多配置方式，参见配置说明 如果你配置完成全局配置后，需要在某次请求中单独设置，可使用如下方式： val config = MoonPermission.Config.newInstance().apply { // 自定义配置 } // 关注失败的调用 CommonSdk.permission().requestWithFailed(Manifest.permission.CAMERA, config = config) { isAllGranted, granted, denied -> // 回调方法 } // 只关注成功的回调 CommonSdk.permission().request(Manifest.permission.CAMERA, config = config) { // 成功回调 } 也可以使用扩展方式进行调用： // 进行单次配置，并且只关注成功的回调 CommonSdk.permission().requestWithConfig(Manifest.permission.CAMERA) { isDeniedUEAvailable = false onSuccess { // 成功回调 } } // 进行单次配置，并且关注成功和失败回调 CommonSdk.permission().requestWithConfig(Manifest.permission.CAMERA) { isDeniedUEAvailable = false onResult { isAllGranted, granted, denied -> // 结果回调 } } 以上两种回调方式不能兼容，只能使用一种方式，如果在开发期间，发现使用了两种回调方式，则会报错。 4. 更多请求权限方式 我们提供了全局声明的方式，进行了方法扩展，提供了三个便捷方法，如下： // 请求权限，只关注成功 requestPermission(Manifest.permission.CAMERA) { // 成功回调 } // 请求权限，关注成功和失败 requestPermissionWithFailed(Manifest.permission.CAMERA) { isAllGranted, granted, denied -> // 结果回调 } // 请求权限，并且进行配置，只关注成功 requestPermissionWithConfig(Manifest.permission.CAMERA) { // 配置 isDeniedUEAvailable = true onSuccess { // 成功回调 } } // 请求权限，并且进行配置，关注成功和失败 requestPermissionWithConfig(Manifest.permission.CAMERA) { // 配置 isDeniedUEAvailable = true onResult { isAllGranted, granted, denied -> // 结果回调 } } Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-11-06 17:57:47 "},"permission/Permission注解.html":{"url":"permission/Permission注解.html","title":"Permission注解","keywords":"","body":"Permission注解 Permission注解功能说明如下： /** * 方法上的权限注解，这里强制要求使用此注解方法的返回类型必须为void，并且注解方法不能为静态方法 * * 使用方式如下： * * 1. 普通调用方式 * * @Permission(Manifest.permission.READ_SMS, Manifest.permission.READ_SMS) * fun test() { * // 业务内容 * } * * 如上，可请求多个权限。如果获取到权限，则会运行test内容，否则将调用通用提示交互 * * 2. 定义次要权限，应该获取，但不是必须权限 * * 如果有部分权限不是必须权限，可以使用如下方式获取： * @Permission(Manifest.permission.READ_SMS, should = [Manifest.permission.WRITE_EXTERNAL_STORAGE]) * fun test() { * // 业务内容 * } * should参数中可存放多个权限，如果should中的权限没有获取成功，也不影响test的调用，其他同1 * * 3. 自定义被拒绝后的处理方式 * * 在1、2中，如果用户拒绝了权限申请，都会直接使用框架默认的交互方式，提示用户授权。如果你关注拒绝后的时机，需要处理一些业务，可如下定义： * @Permission(Manifest.permission.READ_SMS, should = [Manifest.permission.WRITE_EXTERNAL_STORAGE], deniedMethod = \"onDenied\") * fun test() { * // 业务内容 * } * 如上，deniedMethod参数指的是如果必要权限被拒绝后，下一步调用的方法名称。 * 如果用户拒绝了必要权限，框架会尝试调用此方法，使用者可以在此方法中进行处理。 * 我们暂时统一叫此方法为降级方法。在降级方法中，我们支持如下参数列表的声明： * * 1. 带有授权、被拒列表和原始方法入参的方法 * fun onDenied(isAllGranted, granted: Array, denied: Array, 原始方法列表) * * 2. 带有授权、被拒列表的方法 * fun onDenied(isAllGranted, granted: Array, denied: Array) * * 3. 带有授权、被拒列表的方法 * fun onDenied(granted: Array, denied: Array) * * 4. 无参方法 * fun onDenied() * * 如上所示，我们支持以上参数列表。这些被拒方法，都必须和注解方法在同一个类中声明，并且不能为静态方法 * 如果有同名方法，我们优先使用符合条件的方法，如果有多个都符合，我们只调用其中一个方法。优先级为上述顺序。 * * 在有参方法中，请避免使用可变长参数的方法定义方式，以避免不可预期的错误。 * * Created on 2019/1/17 */ @Target(AnnotationTarget.FUNCTION) @Retention(AnnotationRetention.RUNTIME) annotation class Permission( /** * 申请的必要权限名称，例如：Manifest.permission.READ_SMS。 * 可传入多个，这里声明的权限为必要权限，如果其中有一个申请失败，则直接进入失败流程 */ vararg val name: String, /** * 申请的非必要权限名称，以数组方式传入，例如：should = [Manifest.permission.READ_SMS] * 这里声明的权限未非必要权限，如果用户拒绝，也会进入成功流程 */ val should: Array = [], /** * 定义用户拒绝时的回调方法名称，例如：onDeniedMethod = \"onDenied\" * * 如果用户拒绝了必要权限，会回调此方法。 * 我们暂时统一叫此方法为降级方法。在降级方法中，我们支持如下参数列表的声明： * * 1. 带有授权、被拒列表和原始方法入参的方法 * fun onDenied(isAllGranted, granted: Array, denied: Array, 原始方法列表) * * 2. 带有授权、被拒列表的方法 * fun onDenied(isAllGranted, granted: Array, denied: Array) * * 3. 带有授权、被拒列表的方法 * fun onDenied(granted: Array, denied: Array) * * 4. 无参方法 * fun onDenied() * * 如上所示，我们支持以上参数列表。这些被拒方法，都必须和注解方法在同一个类中声明，并且不能为静态方法 * 如果有同名方法，我们优先使用符合条件的方法，如果有多个都符合，我们只调用其中一个方法。优先级为上述顺序。 */ val onDeniedMethod: String = \"\" ) Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-10-29 16:20:16 "},"permission/配置说明.html":{"url":"permission/配置说明.html","title":"配置说明","keywords":"","body":"Permission中的Config 在MoonPermission中，我们提供全局配置和单次请求配置。在单次请求配置中，如果没有定义的内容，将默认使用全局配置中的配置。具体的可配置选项如下(以代码中的为准)： /** * 权限请求的配置选项 * * 在这些配置项中，主要分三部分：deniedRemember权限交互、denied权限交互、全局方法 * * deniedRemember权限交互的含义是：当我们请求权限时，用户可能拒绝权限，并且选择不再提示，这时这部分交互会被触发 * * denied权限交互含义：当我们发起权限请求是，用户可能拒绝，但是并没有勾选不再提示，这时候会触发这部分交互 * * 在这两种配置中，如果是局部配置，如果配置项为null，则尝试使用全局配置的config内容 * */ open class Config { companion object { /** * 使用全局配置，生成一个新config */ fun newInstance(): Config { return Config().apply(CommonSdk.permission().config()) } /** * 使用全新对象，不使用全局配置 */ fun original(): Config { return Config() } } /** * 是否 'denied权限交互' 可用 */ var isDeniedUEAvailable: Boolean? = null /** * 是否 'deniedRemember权限交互' 可用 */ var isDeniedRememberUEAvailable: Boolean? = null /** * 默认deniedRemember权限交互：设置被拒绝后的title，如果设置为null，则使用默认提示 */ var onDeniedRememberTitle: CharSequence? = null /** * 默认deniedRemember权限交互：设置被拒绝后的提示，如果设置为null，则使用默认提示 * * 这个参数接收格式为字符串替代，默认为：\"在设置-应用-应用名称-权限中开启%s权限，以正常使用%s功能\"，你可以定义%s的位置和前后话术 */ var onDeniedRememberDescription: String? = null /** * 默认deniedRemember权限交互：设置被拒绝后的取消按钮文本，如果设置为null，则使用默认提示 */ var onDeniedRememberCancelButton: CharSequence? = null /** * 默认deniedRemember权限交互：设置被拒绝后的去设置按钮文本，在全局设置时不可为空，在局部设置时，如果为空则使用全局的值 */ var onDeniedRememberSettingButton: CharSequence? = null /** * 自定义onDeniedRemember权限交互：设置权限被拒，并且不再提醒后的交互回调，如果此属性设置，则默认deniedRemember权限交互将忽略 * * [denied]被拒的权限列表，[permissionDesc]被拒的权限描述列表， * [onCancel]在后续交互中，用户取消的回调，如果执行此回调，会结束权限申请，并返回结果，一般在弹出框的取消按钮上调用， * [onSubmit]在后续交互中，用户继续的回调，如果执行此回调，会继续权限申请，一般在弹出框的确定、授权按钮上调用 * */ var onDeniedRememberUECallback: OnPermissionUECallback? = null /** * 默认denied权限交互：设置被拒权限后的弹窗title，如果设置为null，则使用默认提示 */ var onDeniedTitle: CharSequence? = null /** * 默认denied权限交互：设置被拒权限后的弹窗的提示，如果设置为null，则使用默认值 * * 这个参数接收格式为字符串替代，默认为：\"请开启%s权限，以正常使用%s功能\"，你可以定义%s的位置和前后话术 */ var onDeniedDescription: String? = null /** * 默认denied权限交互：设置被拒权限后弹窗的取消按钮文本，如果设置为null，则使用默认提示 */ var onDeniedCancelButton: CharSequence? = null /** * 默认denied权限交互：设置被拒权限后弹窗按钮文本，在全局设置时不可为空，在局部设置时，如果为空则使用全局的值 */ var onDeniedButton: CharSequence? = null /** * 自定义denied权限交互：设置被拒权限后的交互回调，如果此属性设置，则默认'denied权限交互'将忽略 * * [denied]被拒的权限列表，[permissionDesc]被拒的权限描述列表， * [onCancel]在后续交互中，用户取消的回调，如果执行此回调，会结束权限申请，并返回结果，一般在弹出框的取消按钮上调用， * [onSubmit]在后续交互中，用户继续的回调，如果执行此回调，会继续权限申请，一般在弹出框的确定、授权按钮上调用 * */ var onDeniedUECallback: OnPermissionUECallback? = null /** * 权限组，用于当用户拒绝时，给用户展示dialog时的权限描述和功能描述 */ var permissionGroups: MutableMap = mutableMapOf() /** * 注册权限组，用于当用户拒绝时，给用户展示dialog时的权限描述和功能描述 */ fun registerPermissionGroup(permission: String, permissionDesc: PermissionDesc) { permissionGroups[permission] = permissionDesc } /** * 使用资源文件的stringArray方式注册权限组，用于当用户拒绝时，给用户展示dialog时的权限描述和功能描述 * * 资源格式必须符合权限组资源格式，如下： * index = 0 : 当前权限组名称 * index = 1 : 当前权限组对应的功能名称 * . : 当前权限组中的权限 * . : 当前权限组中的权限 * . : 当前权限组中的权限 * . : 当前权限组中的权限 * 其中，权限组功能名称可能为无，当为无时，使用短中划线 '-' 进行标记 * 例如： * * 电话 * 通话 * Manifest.permission.ACCEPT_HANDOVER * Manifest.permission.ANSWER_PHONE_CALLS * */ fun registerPermissionGroups(@ArrayRes vararg resIds: Int) { parsePermissionGroupFromRes(*resIds) } /** * 注销权限组 */ fun unregisterPermissionGroup(permission: String) { permissionGroups.remove(permission) } /** * 将入参中的配置信息，补充到当前配置中 */ fun apply(config: Config): Config { isDeniedUEAvailable = isDeniedUEAvailable ?: config.isDeniedUEAvailable isDeniedRememberUEAvailable = isDeniedRememberUEAvailable ?: config.isDeniedRememberUEAvailable onDeniedRememberTitle = onDeniedRememberTitle ?: config.onDeniedRememberTitle onDeniedRememberDescription = onDeniedRememberDescription ?: config.onDeniedRememberDescription onDeniedRememberCancelButton = onDeniedRememberCancelButton ?: config.onDeniedRememberCancelButton onDeniedRememberSettingButton = onDeniedRememberSettingButton ?: config.onDeniedRememberSettingButton onDeniedRememberUECallback = onDeniedRememberUECallback ?: config.onDeniedRememberUECallback onDeniedTitle = onDeniedTitle ?: config.onDeniedTitle onDeniedDescription = onDeniedDescription ?: config.onDeniedDescription onDeniedCancelButton = onDeniedCancelButton ?: config.onDeniedCancelButton onDeniedButton = onDeniedButton ?: config.onDeniedButton onDeniedUECallback = onDeniedUECallback ?: config.onDeniedUECallback permissionGroups = if (permissionGroups.isEmpty()) { config.permissionGroups } else permissionGroups return this } /** * 将当前config应用到全局 */ fun commit() { CommonSdk.permission().config(this) } } 已经定义的资源列表(以代码中的为准)： 电话 通话 android.permission.ACCEPT_HANDOVER android.permission.ANSWER_PHONE_CALLS android.permission.CALL_PHONE android.permission.PROCESS_OUTGOING_CALLS android.permission.READ_CALL_LOG android.permission.WRITE_CALL_LOG android.permission.READ_PHONE_STATE android.permission.READ_PHONE_NUMBERS android.permission.USE_SIP 短信 通讯 android.permission.READ_SMS android.permission.SEND_SMS android.permission.RECEIVE_SMS android.permission.RECEIVE_MMS android.permission.RECEIVE_WAP_PUSH 通讯录 - android.permission.GET_ACCOUNTS android.permission.READ_CONTACTS android.permission.WRITE_CONTACTS 邮件 邮件 android.permission.ADD_VOICEMAIL 位置信息 定位 android.permission.ACCESS_BACKGROUND_LOCATION android.permission.ACCESS_COARSE_LOCATION android.permission.ACCESS_FINE_LOCATION android.permission.ACCESS_LOCATION_EXTRA_COMMANDS android.permission.ACCESS_MEDIA_LOCATION 日历 日程 android.permission.READ_CALENDAR android.permission.WRITE_CALENDAR 身体传感器 - android.permission.ACTIVITY_RECOGNITION android.permission.BODY_SENSORS 设备信息 - android.permission.BATTERY_STATS 相机 拍照、视频 android.permission.CAMERA 相机2 拍照2、视频2 android.permission.CAMERA 麦克风 - android.permission.RECORD_AUDIO 存储 - android.permission.READ_EXTERNAL_STORAGE android.permission.WRITE_EXTERNAL_STORAGE Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-10-29 16:48:07 "},"permission/UpgradeLog.html":{"url":"permission/UpgradeLog.html","title":"版本更新日志","keywords":"","body":"动态权限更新日志 v2.1.1 解决回调错误的bug 新增：isDirectDeniedRememberUE选项的支持，是否直接使用 'deniedRemember权限交互'，舍弃使用 'denied权限交互'。 v2.1.0 更新混淆文件 v2.0.0 为了和之前老版本区分，直接从2.0开始 支持注解动态权限 支持手动调用 支持默认交互 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-11-06 18:17:40 "},"GLOSSARY.html":{"url":"GLOSSARY.html","keywords":"","body":"MoonTools 皓月开发工具,参考 MoonTools moon-tools 皓月开发工具,参考 MoonTools Project 在AS中作为整个工作环境存在，可以包含多个Module。 Module 在AS中作为真正的开发的内容存在，是一个个独立功能的单元模块，可以被其他Module依赖。 kit-upgrade kit库更新日志，参见kit更新文档 KitImport kit库更新日志，参见kit引入文档 Copyright © moon 2019 all right reserved，powered by Gitbook本书发布时间： 2019-08-07 10:33:15 "}}